<!DOCTYPE html>
<!-- Generated by JSLinker -->
<meta name="viewport" content="width=device-width, initial-scale=1">
<html lang="en-US">
    <meta charset="UTF-8">
    <head>
        <title>
Graphite Desktop

        </title>
    </head>
    <body>
        <script>
const System = {
    version: "2.0-rc1 Alpha",
    name: "Graphite"
}/* Copyright Abdurahman Elmawi 2022

The kernel is the javascript hypervisor. All functions that a program runs should go 
through the kernel, either from create_process() or push_process()

The job of the hypervisor is to:
    1. Provide simple APIs for programmers to do what they want with their programs
    2. Centralize and coordinate all programs running on the system
    3. Keep track of program performance and help developers understand their programs
    4. Create a set of security and stability protocols in order to maintain the system
    5. Correct the faults of javascript

*/

const Kernel = {
    name: undefined,
    version: undefined,
    capibilities: [
        "Scheduler",
        "Live Reclocking",
        "Power Management",
        "Overload Protection",
        "Modular",
        "Networking"
    ],
    start_time: Date.now()
};

if (typeof System === "object") {
    Kernel.name = System.name + " Kernel";
    Kernel.version = System.version;
} else {
    console.warn("There was no System defined.");
    Kernel.name = "Unnamed Kernel";
    Kernel.version = "0.0";
}

let canvas, graphics, webgl;

{
    //Option variables
    const suspend_on_unfocus = true;
    const print_debug_logs = false;
    const print_error_logs = true;
    const minimum_cycle_rate = 10;
    const display_performance = true;

    //Customization variables
    const run_loop = true;
    const track_performance = true;
    const manage_power = true;

    const use_graphics = true;
    const use_devices = true;
    const use_networking = true;
    const reassign_jsapi = true;
    const use_init = true;

    const do_logging = true;
    const error_handler = true;
    const track_cycle_info = true;

    const use_watchdog = true;
    const overload_protection = true;

    //Auto-set constants
    const windowed = (typeof window !== "undefined");
    const is_browser = (typeof document === "object");

    //Debug logging
    let debug = function () { };
    let warn = function () { };
    let error = function () { };
    if (do_logging === true) {
        let debug_logs = [];
        let debug_object = function (message, level) {
            this.message = message;
            this.level = level;
            this.date = Date.now();
        }
        debug = function (message) {
            debug_logs.push(new debug_object(message, 0));
            if (print_debug_logs === true)
                console.debug(message);
        }
        warn = function (message) {
            debug_logs.push(new debug_object(message, 1));
            if (print_debug_logs === true)
                console.warn(message);
        }
        error = function (message) {
            debug_logs.push(new debug_object(message, 2));
            if (print_error_logs === true)
                console.error(message);
        }
        function print_kernel_debug() {
            debug("Printing kernel debug logs");
            console.warn("Printing kernel debug logs");
            let parsed_kernel_logs = "";
            for (let i = 0; i < debug_logs.length; i++) {
                let log = debug_logs[i];
                let message_parse = "[" + (log.date - Kernel.start_time) + "] " + log.message;
                parsed_kernel_logs += message_parse + "\n";
                switch (log.level) {
                    case 0:
                        console.debug(message_parse);
                        break;
                    case 1:
                        console.warn(message_parse)
                        break;
                    case 2:
                        console.error(message_parse)
                        break;
                }
            }
            return parsed_kernel_logs;
        }
    }

    //Panic
    let panicked = false;
    let panic = function (message) {
        if (panicked === false) {
            panicked = true;
            clear_timers();
            kernel_daemons = [];
            console.error("Critical: Kernel panic (" + message + ")");
            error("Kernel panicked: " + message);
            processes = [];
            threads = [];
            print_kernel_debug();
            if (windowed === true)
                alert("Kernel panic -> " + message);
        }
    }

    //Timing profile
    let time_tracker;
    {
        let continue_testing = true;
        let test_time_tracker = function (handler) {
            if (continue_testing === true) {
                try {
                    handler();
                } catch (e) {

                } finally {
                    continue_testing = false;
                    time_tracker = handler;
                }
            }
        }
        test_time_tracker(() => { return performance.now(); });
        test_time_tracker(() => { return Date.now(); });
        test_time_tracker(() => { return millis(); });
        if (continue_testing === true)
            panic("No time tracker was able to be established.");
    }
    function get_time() {
        return Math.floor(time_tracker() * 100) / 100;
    }

    //Javascript API reassignment
    let set_timeout = setTimeout;
    let set_interval = setInterval;
    if (reassign_jsapi === true) {
        debug("Reassigning Javascript APIs for security");
        setTimeout = function () {
            warn("setTimeout was called.");
        }
        setInterval = function () {
            warn("setInterval was called.");
        }
    }

    //Hashing
    function hash(num) {
        let result = 0;
        for (let i = 0; i <= num; i++) {
            result += num * (Math.sqrt(i) * (i + 1)) - num;
            result = result >> 1;
        }
        result += num;
        result = Math.round(result);
        return result;
    }
    function hash_string(string) {
        let result = 0;
        for (let i = 0; i < string.length; i++) {
            let char = string[i].charCodeAt();
            result += char * (Math.sqrt(char) * (i + 1)) - char;
            result = result >> 1;
        }
        return result;
    }

    //Kernel key management
    const kernel_key = hash(Math.random() * 1000);
    function get_kernel_key() {
        console.warn("[" + (Date.now() - Kernel.start_time) + "]: Kernel key was accessed.");
        let confirmation = true;
        if (windowed === true)
            confirmation = confirm("A program is requesting root access. Accept?");
        if (confirmation === true) {
            warn("The kernel key was accessed");
            return kernel_key;
        } else {
            error("The kernel key was requested, but declined.");
            return Math.random();
        }
    }

    //Internal use functions
    let run_command_buffer = function (command) {
        (function () { command(); })();
    }

    //Kernel daemons
    let kernel_daemons = [];
    let Kernel_daemon = function (handler) {
        this.command = handler;
        this.daemon_name = handler.name;
    }
    Kernel_daemon.prototype.run = function () {
        try {
            run_command_buffer(this.command);
        } catch (e) {
            console.error(e);
            panic("Kernel daemon '" + this.daemon_name + "' encountered an error.");
        }
    }
    let add_kernel_daemon = function (handler) {
        kernel_daemons.push(new Kernel_daemon(handler));
        return kernel_daemons.length - 1;
    }
    let run_kernel_daemons = function () {
        for (let i = 0; i < kernel_daemons.length; i++)
            kernel_daemons[i].run();
    }

    //Root execution
    function run_as_root(command_string, key) {
        let command_output;
        if (key === kernel_key) {
            command_output = eval(command_string);
            debug("'" + command_string + "' was run at kernel level");
        } else
            error("A security breach was detected. Command '" + command_string + "' was attempted to be run at root level.");
        return command_output;
    }

    //Uptime
    function raw_uptime() {
        let full_uptime = Date.now() - Kernel.start_time
        let suspended_time = get_suspended_time();
        let result = {
            total: full_uptime,
            suspended: suspended_time,
            active: full_uptime - suspended_time
        }
        return result;
    }
    function uptime() {
        let uptime_message;
        {
            let uptime_buffer = raw_uptime().total;
            let seconds = Math.floor(uptime_buffer / 1000 % 60)
            let minutes = Math.floor(uptime_buffer / 1000 / 60 % 60);
            let hours = Math.floor(uptime_buffer / 1000 / 3600);
            uptime_message = "Total: " + hours + ":" + minutes + ":" + seconds;
        }

        let running_message;
        {
            let active_uptime = raw_uptime().active;
            let seconds = Math.floor(active_uptime / 1000 % 60);
            let minutes = Math.floor(active_uptime / 1000 / 60 % 60);
            let hours = Math.floor(active_uptime / 1000 / 3600);
            running_message = "Running: " + hours + ":" + minutes + ":" + seconds;
        }

        return uptime_message + "\n" + running_message;
    }

    //Error management
    let error_screen;
    if (error_handler === true) {
        let error_screen_handler = function () {//Default 

        };
        error_screen = {
            triggered: false,
            process: undefined,
            error: undefined
        }
        let error_screen_daemon = () => { }
        add_kernel_daemon(error_screen_daemon);
        function set_error_screen(handler) {
            error_screen_handler = handler;
        }
    }

    //Threads
    let PIDs = 0;
    let thread_in_execution = null;
    let Thread = function (command) {
        this.command = command;
        this.process = process_in_execution.PID;
        if (process_in_execution === null)
            error("A thread was created outside of a process context.");
        this.sleep_time = 0;
        this.last_execution = 0;
        this.dead = false;
        this.PID = PIDs;
        PIDs++;
    }
    Thread.prototype.run = function () {
        this.last_execution = get_time();
        thread_in_execution = this;
        try {
            run_command_buffer(this.command);
        } catch (e) {
            if (e !== "interrupt") {
                console.error("Process " + this.process_name + " (" + this.PID + ") has encountered an error.");
                console.error(e);
                this.dead = true;
            }
        }
        waiting_processes++;
    }
    //Processes
    let processes = [];
    let user_time_buffer = 0;
    let process_in_execution = null;
    let Process = function (command) {
        this.process_name = command.name;
        this.threads = [];
        if (use_init === true) {
            if (process_in_execution === null)
                error("Process '" + this.process_name + "' was created outside of a process context.");
            else
                this.parent = process_in_execution.PID;
        }
        this.creation_time = get_time();
        this.starting_uptime = raw_uptime().active;
        this.full_execution_time = 0;
        this.exec_time = 0;
        this.cpu_time = 0;
        this.suspended = false;
        this.dead = false;
        this.PID = PIDs;

        //Main thread creation
        process_in_execution = this;
        this.threads.push(new Thread(command));
    }
    Process.prototype.run = function (time_marker, start_time, target_time) {
        if (this.suspended === false) {
            process_in_execution = this;
            this.full_execution_time = time_marker - this.last_execution;
            this.last_execution = time_marker;
            for (let i = 0; i < this.threads.length; i++) {//Run all threads
                let thread = this.threads[i];
                if (thread.dead === true)
                    this.threads.splice(i, 1);
                else if (thread.sleep_time + thread.last_execution <= start_time)
                    thread.run();
                if (thread.last_execution >= target_time) //Scheduler watchdog
                    break;
            }
            if (this.threads.length === 0)
                this.dead = true;
        }
        let time_buffer = get_time();
        this.exec_time = time_buffer - time_marker;
        user_time_buffer += this.exec_time;
        this.cpu_time += Math.floor(this.exec_time * 100) / 100;
        return time_buffer;
    }
    Process.prototype.thread = function (command) {
        process_in_execution = this;
        this.threads.push(new Thread(command));
    }
    function create_process(command) {
        processes.push(new Process(command));
        return PIDs - 1;
    }
    function spawn_process(command) {
        return new Process(command);
    }
    function push_process(process) {
        processes.push(process);
    }
    let find_by_pid = function (PID) {
        let result = {
            index: {},
            process: {}
        };
        for (let i = 0; i < processes.length; i++) {
            if (processes[i].PID === PID) {
                result = {
                    index: i,
                    process: processes[i]
                }
            }
        }
        return result;
    }
    function kill(PID) {
        find_by_pid(PID).process.dead = true;
        debug("Killed " + PID);
    }
    function suspend(PID) {
        find_by_pid(PID).process.suspended = true;
        debug("Suspended " + PID);
    }
    function resume(PID) {
        find_by_pid(PID).process.suspended = false;
        debug("Resumed " + PID);
    }

    //Devices
    if (use_devices === true && windowed === true && is_browser === true) {
        let devices = {};
        //Mouse
        devices.mouse = {
            x: 0,
            y: 0,
            vectorX: 0,
            vectorY: 0,
            clicked: false
        };
        document.onmousemove = event => {
            devices.mouse.vectorX = devices.mouse.x - event.pageX + 8;
            devices.mouse.vectorY = devices.mouse.y - event.pageY + 8;
            devices.mouse.x = event.pageX - 8;
            devices.mouse.y = event.pageY - 8;
        };
        document.onmousedown = () => {
            devices.mouse.clicked = true;
            devices.mouse.pressed = true;
        };
        document.onmouseup = () => {
            devices.mouse.clicked = false;
            devices.mouse.pressed = false;
        };
        //Keyboard
        devices.keyboard = {
            keys: [],
            keyCodes: [],
            pressed: false,
            keyCode: 0,
            info: {},
        };
        document.onkeydown = event => {
            devices.keyboard.keyCodes[event.keyCode] = true;
            devices.keyboard.keys.push(event.key);
            devices.keyboard.pressed = true;
            devices.keyboard.info = event;
        };
        document.onkeyup = event => {
            devices.keyboard.keyCodes[event.keyCode] = false;
            devices.keyboard.pressed = false;
            devices.keyboard.info = event;
        };
        //Controllers
        devices.controllers = [];
        window.addEventListener("gamepadconnected", e => {
            debug("Device: Controller " + e.gamepad.index + " connected (" + e.gamepad.id + ")");
            devices.controllers.push(e.gamepad);
        });
        window.addEventListener("gamepaddisconnected", e => {
            debug("Device: Controller " + e.gamepad.index + " disconnected (" + e.gamepad.id + ")");
            devices.controllers.splice(e.gamepad, 1);
        });
        function get_devices() {
            return JSON.parse(JSON.stringify(devices));
        }
    }

    //Networking
    if (use_networking === true) {
        let init_networking = function () {
            let xml_http = new XMLHttpRequest();
            xml_http.addEventListener('error', (event) => {
                error("A network request failed");
            });
            return xml_http;
        }
        let run_network_request = function (handler) {
            try {
                handler();
            } catch (e) {
                console.error(e);
                console.error("A network request encountered an error.");
                error("A network request has encountered an error");
            }
        }
        function net_get(url, handler) {
            run_network_request(() => {
                let xml_http = init_networking();
                xml_http.onreadystatechange = function () {
                    if (this.readyState == 4 && this.status == 200)
                        handler(this.responseText);
                }
                xml_http.open("GET", url, true);
                xml_http.send(null);
            });
        }
        function net_send(url, data) {
            run_network_request(() => {
                let xml_http = init_networking();
                const urlEncodedDataPairs = [];
                for (const [name, value] of Object.entries(data)) {
                    urlEncodedDataPairs.push(`${encodeURIComponent(name)}=${encodeURIComponent(value)}`);
                }
                xml_http.addEventListener('load', (event) => {
                    debug("Network send request successful");
                });
                const urlEncodedData = urlEncodedDataPairs.join('&').replace(/%20/g, '+');
                xml_http.open('POST', url);
                xml_http.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');
                xml_http.send(urlEncodedData);
            });
        }
    }

    //Graphics
    if (use_graphics === true && windowed === true && is_browser === true) {
        debug("Initializing graphics stack");
        canvas = document.createElement("canvas");
        if (!canvas)
            error("Graphics: Failed to create canvas.");
        graphics = canvas.getContext('2d');
        if (!graphics)
            error("Graphics: Failed to load 2d context.");
        webgl = canvas.getContext('webgl');
        if (!webgl)
            debug("Graphics: Failed to load webgl context.");
        canvas.id = "canvas";
        canvas.width = window.innerWidth - 20;
        canvas.height = window.innerHeight - 21;
        document.body.appendChild(canvas);
    }

    //Sound
    function play_sound(url) {
        try {
            new Audio(url).play();
        } catch (e) {
            error("Sound '" + url + "' failed to play.");
        }
    }

    //Suspension
    let system_suspended = false;
    let execution_time = 0;
    {
        let time_suspended = 0;
        let time_marker = get_time();
        let suspend_system = function () {
            if (system_suspended !== true) {
                execution_time = 500;
                system_suspended = true;
                time_marker = get_time();
            }
        }
        let resume_system = function () {
            if (system_suspended !== false) {
                execution_time = 0;
                system_suspended = false;
                time_suspended += get_time() - time_marker;
            }
        }
        function get_suspended_time() {
            if (system_suspended !== true)
                return time_suspended;
            else
                return time_suspended + get_time() - time_marker;
        }
        if (suspend_on_unfocus === true && windowed === true && is_browser === true) {
            let suspend_daemon = function () {
                if (document.hasFocus())
                    resume_system();
                if (!document.hasFocus())
                    suspend_system();
            }
            add_kernel_daemon(suspend_daemon);
        }
    }

    //System process
    let system_process;
    {
        let system = () => {
            sleep(10000);
        };
        process_in_execution = { PID: 0 };
        thread_in_execution = {};
        system_process = new Process(system);
        process_in_execution = null;
        thread_in_execution = null;
    }

    //Scheduler
    let scheduler_run_count = 0;
    let sched_overhead = 0;
    let user_time = 0;
    let scheduler = function () {
        if (system_suspended !== true) {
            let start_time = get_time();
            let target_time = 1000 / minimum_cycle_rate + start_time;
            let time_marker = start_time;
            processes.sort((a, b) => a.exec_time - b.exec_time);//Prioritize light processes
            user_time_buffer = 0;
            for (let i = 0; i < processes.length; i++) {
                let process = processes[i];
                time_marker = process.run(time_marker, start_time, target_time);
                if (process.dead === true)
                    processes.splice(i, 1);
            }
            process_in_execution = null;
            thread_in_execution = null;
            sched_overhead = get_time() - start_time - user_time_buffer;
            user_time = user_time_buffer;
            scheduler_run_count++;
        }
    }

    {//Thread-process management APIs
        let run_kernel_api = function (handler) {
            if (thread_in_execution !== null && process_in_execution !== null)
                handler();
            else
                warn("A kernel API was called outside of a process context. (process: " + process_in_execution + ", thread: " + thread_in_execution + ")");
        }
        function interrupt() {
            throw "interrupt";
        }
        function sleep(timeout) {
            run_kernel_api(() => {
                thread_in_execution.sleep_time = timeout;
            });
        }
        function thread(command) {
            run_kernel_api(() => {
                process_in_execution.thread(command);
            });
        }
        function fork() {
            run_kernel_api(() => {
                // let process = new Process(process_in_execution.command);
                // process.process_name = thread_in_execution.process_name;
                processes.push(process_in_execution);
            });
        }
        function exec(command) {
            run_kernel_api(() => {
                thread_in_execution.command = command;
            });
        }
        function getpid() {
            let pid;
            run_kernel_api(() => {
                pid = thread_in_execution.PID;
            });
            return pid;
        }
        function exit() {
            run_kernel_api(() => {
                thread_in_execution.dead = true;
            });
        }
        function proc() {
            return process_in_execution;
        }
    }

    //Timer management
    let timers = [];
    function create_timeout(handler, time) {
        if (panicked === false) {
            let process_context = process_in_execution;
            let timer_id = set_timeout(() => {
                process_in_execution = process_context
                handler();
                process_in_execution = null;
                timers.splice(timer_id);
            }, time);
            timers.push(timer_id);
            return timer_id;
        }
    }
    let create_interval = function (handler, time) {
        let timer_id = set_interval(() => {
            handler();
            timers.splice(timer_id);
        }, time);
        debug("Interval '" + handler.name + "' was created");
        timers.push(timer_id);
        return timer_id;
    }
    let clear_timers = function () {
        warn("All timers were cleared");
        while (timers.length > 0) {
            clearTimeout(timers[0]);
            timers.splice(0, 1);
        }
    }

    //Performance tracking
    let realtime_performance = 1;
    let system_overhead = 0;
    let system_time = 0;
    let kernel_overhead = 0;
    let waiting_processes = 0;
    if (track_performance === true) {
        let low_performance_mode = false;
        let percent_total = 0;
        let percent_system = 0;
        let percent_user = 0;
        let percent_idle = 0;
        let load_average = 0;
        {
            let timer = get_time();
            let performance_tracker = function () {
                let time_buffer = get_time();
                realtime_performance = time_buffer - timer;
                timer = time_buffer;
                if (percent_total === NaN)
                    percent_total = 0;
                if (percent_system === NaN)
                    percent_system = 0;
                if (percent_user === NaN)
                    percent_user = 0;
                if (system_suspended !== true && realtime_performance > 0) {
                    let n = Math.min(scheduler_run_count - 1, 1000 / realtime_performance);
                    percent_total = ((system_time / realtime_performance) + n * percent_total) / (n + 1);
                    percent_system = ((kernel_overhead / realtime_performance) + n * percent_system) / (n + 1);
                    percent_user = ((user_time / realtime_performance) + n * percent_user) / (n + 1);
                    percent_idle = (((realtime_performance - system_time) / realtime_performance) + n * percent_idle) / (n + 1);

                    if (scheduler_run_count >= 1) {
                        let n = Math.min(scheduler_run_count - 1, 5000 / realtime_performance);
                        load_average = (waiting_processes + n * load_average) / (n + 1);
                        waiting_processes = 0;
                    }
                }
            }
            add_kernel_daemon(performance_tracker);
        }
        //Gauge performance
        {
            let performance_tracker = handler => {
                let time_marker = get_time();
                handler();
                return get_time() - time_marker;
            }
            let test = () => {
                for (let i = 0; i < 1000000; i++) {
                    let hi = function () { };
                    hi();
                }
            }
            let test_scores = [];
            const test_count = 3;
            let median_score = 0;
            for (let i = 0; i < test_count; i++) {
                test_scores.push(performance_tracker(test));
            }
            test_scores = test_scores.sort((a, b) => a - b);
            if (test_count % 2 === 1) {
                median_score = test_scores[Math.round(test_count / 2) - 1];
            } else {
                median_score = (test_scores[Math.round(test_count / 2)] + test_scores[Math.floor(test_count / 2) - 1]) / 2;
            }
            const score = Math.floor(100 / median_score);
            debug("Performance test score: " + score);
            if (score < 26)
                low_performance_mode = true;
        }
        function get_performance() {
            const const_realtime_performance = realtime_performance;
            let result = {
                realtime: const_realtime_performance,
                average: load_average,
                percent: percent_total * 100,
                percent_user: percent_user * 100,
                percent_system: percent_system * 100,
                percent_idle: percent_idle * 100,
                overhead: system_overhead,
                system: system_time,
                low_performance: low_performance_mode
            }
            return result;
        }
        //QOL functions
        function ktop() {
            let output_text = "";
            let add_text = function (line) {
                // console.log(line);
                output_text += line + "\n";
            }
            let round_hundredth = function (number) {
                return Math.round(number * 100) / 100;
            }
            let get_percent = function (number) {
                return Math.round(number * 100);
            }
            add_text("-- ktop --");
            add_text("CPU usage: " + get_percent(percent_total) + "% total (" + get_percent(percent_user) + "% user, " + get_percent(percent_system) + "% system, " + get_percent(percent_idle) + "% idle)");
            add_text("Task count: " + (processes.length));
            add_text("Uptime: " + uptime());
            add_text("Load average: " + round_hundredth(load_average));
            add_text("- Kernel info -");
            add_text("System time: " + round_hundredth(system_time) + "ms")
            add_text("User time: " + round_hundredth(user_time) + "ms");
            add_text("Kernel time: " + round_hundredth(kernel_overhead) + "ms (" + round_hundredth(sched_overhead) + "ms sched)");
            add_text("Realtime performance: " + round_hundredth(realtime_performance) + "ms");
            add_text("JS engine overhead: " + round_hundredth(system_overhead) + "ms");
            add_text("- Individual process usages - ");

            let sorted_processes = processes.sort((a, b) => b.cpu_time - a.cpu_time);
            for (let i = 0; i < sorted_processes.length; i++) {
                let process = sorted_processes[i];
                add_text(process.process_name + "(" + process.PID + ") - " + (Math.round(process.cpu_time / (raw_uptime().active - process.starting_uptime) * 10000) / 100) + "% CPU - " + (Math.round(process.cpu_time / 10) / 100) + " seconds CPU time - " + round_hundredth(process.exec_time) + "ms exec time - " + Math.round(process.sleep_time) + "ms sleep time");
            }

            return output_text;
        }
        function get_system_info() {
            let get_percent = function (number) {
                return number * 100;
            }
            let result = {
                usage: {
                    total: get_percent(percent_total),
                    user: get_percent(percent_user),
                    system: get_percent(percent_system),
                    idle: get_percent(percent_idle),
                    load_average: load_average
                },
                info: {
                    system_time: system_time,
                    kernel_overhead: kernel_overhead,
                    sched_overhead: sched_overhead,
                    user_time: user_time,
                    realtime: realtime_performance,
                    js_overhead: system_overhead,
                },
                processes: []
            }
            for (let i = 0; i < processes.length; i++) {
                let process = processes[i];
                let process_name = process.process_name;
                if (process_name === "")
                    process_name = "unnamed";
                let process_buffer = {
                    process_name: process_name,
                    PID: process.PID,
                    cpu_time: process.cpu_time,
                    exec_time: process.exec_time,
                    sleep_time: process.sleep_time,
                    creation_time: process.creation_time,
                    starting_uptime: process.starting_uptime
                }
                result.processes.push(process_buffer);
            }
            return result;
        }
        function perf_track(command) {
            let time_marker = get_time();
            command();
            return get_time() - time_marker;
        }
    }

    //Performance display
    if (display_performance === true) {
        let performance_display = function () {
            //TODO: Make default performance display
        }
        let daemon_id = add_kernel_daemon(performance_display);
        function set_performance_display(handler) {
            kernel_daemons[daemon_id].command = handler;
            debug("Performance display has been set (" + handler.name + ")");
        }
    }

    //Power manager
    if (manage_power === true) {
        let power_manager = function () {
            if (system_suspended !== true) {
                let minimum_execution_point = Infinity;
                let time_buffer = get_time();
                for (let i = 0; i < processes.length; i++) {
                    let process = processes[i];
                    for (let l = 0; l < process.threads.length; l++) {
                        let thread = process.threads[l];
                        if (thread.sleep_time !== 0) {
                            let scheduled_exec = thread.last_execution + thread.sleep_time - time_buffer;
                            if (scheduled_exec < minimum_execution_point)
                                minimum_execution_point = scheduled_exec;
                        }
                    }
                }
                if (minimum_execution_point !== Infinity)
                    execution_time = Math.max(minimum_execution_point, 0);
            }
        }
        add_kernel_daemon(power_manager);
    }

    //Watchdog
    if (use_watchdog === true) {
        debug("Initializing watchdog");
        let timer = 0;
        let previous_execution_count = 0;
        let watchdog = function () {
            if (previous_execution_count === execution_count)
                warn("Watchdog has been triggered");
            else if (previous_execution_count < execution_count) {
                timer = get_time();
                previous_execution_count = execution_count;
            }
            if (get_time() - timer > 2000)
                panic("Watchdog has detected that the kernel is hung.");
        }
        create_interval(watchdog, 1000);
    }

    //Overload protection
    if (overload_protection === true) {
        debug("Initializing overload protection");
        let scheduler_cycle_count = 0;
        let cycle_count_buffer = 0;
        let timer = 0;
        const watchdog_timeout = 3000;
        let overload_monitor = function () {
            if (system_suspended !== true) {
                if (cycle_count_buffer === scheduler_cycle_count) {
                    warn("Overload monitor has been triggered");
                } else if (cycle_count_buffer < scheduler_cycle_count) {
                    timer = get_time();
                    cycle_count_buffer = scheduler_cycle_count;
                }
                if (get_time() - timer > watchdog_timeout)
                    panic("System has been overloaded");
            } else {
                timer = get_time();
            }
        }
        create_interval(overload_monitor, watchdog_timeout - 500);
        system_process.thread(() => {
            scheduler_cycle_count++;
            sleep(watchdog_timeout / 2);
        });
    }

    //Init
    if (use_init === true) {
        let inits = [];
        system_process.thread(() => {
            if (inits.length !== 0) {
                for (let i = inits.length; i > 0; i--) {
                    debug("Intializing " + inits[0].name);
                    create_process(inits[0])
                    inits.splice(0, 1);
                }
            }
            sleep(500);
        });
        function create_init(command) {
            inits.push(command);
        }
    }
    push_process(system_process);

    //Main loop
    let execution_count = 0;
    {
        let overhead_time_marker = 0;
        let main = function () {
            try {
                let time_marker = get_time();
                system_overhead = time_marker - overhead_time_marker - execution_time;
                scheduler();//Run processes
                run_kernel_daemons();
                execution_count++;
                //Rexecute loop
                if (run_loop === true && panicked === false)
                    create_timeout(main, execution_time);
                let time_marker_2 = get_time();
                system_time = time_marker_2 - time_marker;
                kernel_overhead = system_time - user_time;
                overhead_time_marker = time_marker_2;
            } catch (e) {
                console.error(e);
                panic("Kernel execution encountered an error.");
            }
        }
        console.log(Kernel.name + " " + Kernel.version);
        try {
            debug("Starting kernel");
            main();
        } catch (e) {
            console.error(e);
            panic("Unable to start kernel");
        } finally {
            let time_since_start = (Date.now() - Kernel.start_time);
            console.log("Kernel successfully started. (" + time_since_start + "ms)");
            debug("Kernel was started in " + time_since_start + "ms");
        }
    }
}{
    let Tracker = function(){
        this.time_marker = performance.now();
        this.measured_latency = 0;
    }
    Tracker.prototype.update = function (){
        let time = performance.now();
        this.measured_latency = time - this.time_marker;
        this.time_marker = time;
    }
    function create_timer() {
        return new Tracker();
    }
    function getTransition(size, time, timer){
        if(timer === undefined){
            return (Math.abs(size) / (1000 / get_performance().scheduler)) * (1000 / time);
        } else {
            return (Math.abs(size) / (1000 / timer.measured_latency)) * (1000 / time);
        }
    }
}
set_performance_display(() => {
    let counter_count = 2;
    graphics.fillStyle = '#AAAAAA';
    graphics.fillRect(0, 0, 38 * counter_count, 30);
    graphics.fillStyle = 'black';
    graphics.font = '14px Monospace';
    graphics.fillText(Math.round(get_performance().realtime), 10, 19);
    graphics.fillText(Math.round(get_performance().percent), 10 + (38 * 1), 19);
});var applications = [];
var applicationReloadTriggered = false;
class Application {
    constructor(handler, icon){
        this.handler = handler;
        this.icon = icon;
    }
}
function triggerApplicationReload() {
    applicationReloadTriggered = true;
}
function addApplication(handler, icon){
    applications.push(new Application(handler, icon));
    triggerApplicationReload();
}
function addApplicationFromClass (appClass) {
  var currentAppClass = new appClass;
  addApplication(currentAppClass.create_window, currentAppClass.iconFunction);
}
function renderApplicationIcon(application){
    push();
    application.icon();
    pop();
}
function runApplication(application){
    application.handler();
}
var animateSystem = true;
var buttonClicked = false;
var listViewOpened = "";
let darkmode = false;

//Color scheme
let colorScheme = {
    accent: '#466EFF',
    background: "black",
    dialogueBackground: "#1E1E1E",
    elementColors: "#1E1E1E",
    textColor: "white",
};

//GUI Elements
function setBackground(canvas, graphics){
    graphics.fillStyle = colorScheme.background;
    graphics.fillRect(0, 0, canvas.width, canvas.height);
}
function centerText(graphics, displayText, textX, textY, textW, textH, textStyle) {
    let currentTextStyle = 12;
    if (textStyle) {
        currentTextStyle = textStyle;
    }
    graphics.font = currentTextStyle + "px Monospace";
    const textDisplayX = textX + ((textW / 2) - (graphics.measureText(displayText).width / 2));
    const textDisplayY = textY + ((textH / 2) + (currentTextStyle / 3));
    graphics.fillText(displayText, textDisplayX, textDisplayY);
}
function simpleCenterText(graphics, displayText, textX, textY){
    graphics.fillText(displayText, textX - textWidth(displayText)/2, textY);
}
function blankButton(x, y, w, h, func){
    let devices = get_devices();
    if (devices.mouse.x > x && devices.mouse.x < x + w && devices.mouse.y > y && devices.mouse.y < y + h && devices.mouse.clicked && buttonClicked === false) {
        func();
        buttonClicked = true;
    }
}
function Button(graphics, x, y, w, h, func) {
    graphics.save();
    let devices = get_devices();
    if (devices.mouse.x > x && devices.mouse.x < x + w && devices.mouse.y > y && devices.mouse.y < y + h) {
        graphics.strokeStyle = colorScheme.accent;
        graphics.lineWidth = 1.8;

        if(devices.mouse.clicked && buttonClicked === false){
            func();
            buttonClicked = true;
        }
    }else{
        graphics.strokeStyle = colorScheme.elementColors;
    }
    graphics.fillStyle = colorScheme.elementColors;
    
    graphics.beginPath();
    graphics.moveTo(x,y);
    graphics.lineTo(x,y);
    graphics.lineTo(x+w, y);
    graphics.lineTo(x+w,y+h);
    graphics.lineTo(x,y+h);
    graphics.lineTo(x,y);
    graphics.lineTo(x+w, y);
    graphics.fill();
    graphics.stroke();
    graphics.restore();
}
function labledButton(graphics, x, y, w, h, func, buttonText){
    Button(graphics, x, y, w, h, func);
    graphics.fillStyle = colorScheme.textColor;
    centerText(graphics, buttonText, x, y, w, h);
}
function booleanToggleButton(graphics, bool, textFalse, textTrue, x, y, w, h, customFunction, textColor){
    let currentCustomFunction = customFunction;
    if(!customFunction){
        currentCustomFunction = () => {};
    }
    let result = bool;
    function changeBoolean(){
        if(!bool){
            result = true;
            currentCustomFunction(result);
            return;
        }
        if(bool){
            result = false;
            currentCustomFunction(result);
            return;
        }
    }
    graphics.save();
    if(bool === false){
        labledButton(graphics, x, y, w, h, changeBoolean, textFalse, textColor);
    }
    if(bool === true){
        labledButton(graphics, x, y, w, h, changeBoolean, textTrue, textColor);
    }
    graphics.restore();
    return result;
}
function listSelector(graphics, variable, options, x, y, w, h, text, customFunction){
    let result = variable;
    let devices = get_devices();
    function openMenu(){
        listViewOpened = text;
        this.mouseClickedX = devices.mouse.x;
        this.mouseClickedY = devices.mouse.y;
    }
    let _customFunction = () => {};
    if(customFunction){
        _customFunction = customFunction;
    }
    graphics.save();
    if(listViewOpened === text){
        let menuClicked = false;
        for(var i = 0; i < options.length; i++){
            graphics.save();
            labledButton(graphics, x, y + (h*i), w, h, () => {
                result = options[i][0];
                listViewOpened = "";
                _customFunction();
                menuClicked = true;
            }, options[i][1]);
            graphics.restore();
        }
    }
    if(listViewOpened.length < 1){
        labledButton(graphics, x, y, w, h, openMenu, text);
    }
    graphics.restore();
    return result;
}
//Reset button clicked status
let toolkitd = function(){
    if(get_devices().mouse.clicked === false){
        buttonClicked = false;
    }
    sleep(20)
}
create_init(toolkitd);
//Animation handler
function animateAcceleration(value, targetSize, time) {
    if(animateSystem === true){
        if (Math.round(value) !== targetSize) {
            return getTransition(targetSize - value, time, true);
        } else {
            return 0;
        }
    }else{
        return targetSize - value;
    }
}

//Image tools
function setTheme(is_darkmode){
    if(is_darkmode !== undefined)
        darkmode = is_darkmode;
    let pictureData = get_background_image().data;

    let a = 0;
    let r = 0;
    let g = 0;
    let b = 0;
    for(var i = 0; i < pictureData.length; i+=4){
        r += pictureData[i];
        g += pictureData[i+1];
        b += pictureData[i+2];
        a += pictureData[i+3];

    }

    let result = {
        r: r/(i/4),
        g: g/(i/4),
        b: b/(i/4),
        a: a/(i/4)
    }
    // return result

    let primaryColor = Math.max(result.r, result.g, result.b);
    let scaleColor = function(color){
        if(darkmode === true)
            return (color/primaryColor)*255
        else
            return (color/primaryColor)*128
    }

    let accent_color = "rgb(" + scaleColor(result.r) + ", " + scaleColor(result.g) + ", " + scaleColor(result.b) + ")";

    let background_opacity = 160;
    let scaleBg = function(color){
        if(darkmode === true)
            return color * (background_opacity / 255);
        else
            return 255 - ((primaryColor - color) * (background_opacity / 255));
    }
    let bg_color = "rgb(" + scaleBg(result.r) + ", " + scaleBg(result.g) + ", " + scaleBg(result.b) + ")";
    // background = "white"

    if(darkmode === true){
        colorScheme = {
            accent: accent_color,
            background: "black",
            dialogueBackground: "#1E1E1E",
            elementColors: "#1E1E1E",
            textColor: "white",
        };
    } else {
        colorScheme = {
            accent: accent_color,
            background: "white",
            dialogueBackground: "#E1E1E1",
            elementColors: "#E1E1E1",
            textColor: "black",
        };
    }
}class Settings {
    update (canvas, graphics){
        //App background
        setBackground(canvas, graphics);

        graphics.fillStyle = "#282828";
        //Settings
        // showPerformanceInfo = booleanToggleButton(graphics, showPerformanceInfo, "Turn on FPS display", "Turn off FPS display", 10, 10, canvas.width-20, 30);
        // trackPerformance = booleanToggleButton(graphics, trackPerformance, "Track processes performance", "Untrack processes performance", 10, 50, canvas.width-20, 30);
        // preemptiveKernel = booleanToggleButton(graphics, preemptiveKernel, "Enable preemptive scheduler", "Disable preemptive scheduler", 10, 90, canvas.width-20, 30);
        // limitFps = booleanToggleButton(graphics, limitFps, "Enable FPS limiter", "Disable FPS limiter", 10, 130, canvas.width-20, 30);
        // idleSuspend = booleanToggleButton(graphics, idleSuspend, "Suspend at idle", "Do not suspend at idle", 10, 170, canvas.width-20, 30);
        darkmode = booleanToggleButton(graphics, darkmode, "Light mode", "Dark mode", 10, 210, canvas.width-20, 30, setTheme);
        // displayScaling = booleanToggleButton(graphics, displayScaling, "Scale display", "Do not scale display", 10, 210, canvas.width-20, 30);
        cursorShape = listSelector(graphics, cursorShape, [
            [simpleCursor, "Simple"],
            [winCursor, "Windows"],
            [winCursorOG, "Windows OG"],
            [macCursor, "Mac"],
            [kCursor, "kCursor"],
        ], 10, 250, canvas.width-20, 30, "Cursor Shape", () => {
            renderMouseCursor = graphics => {
                cursorColor(graphics);
                cursorShape(graphics);
            }
            set_cursor(renderMouseCursor);
        });
        cursorColor = listSelector(graphics, cursorColor, [
            [colorWhiteCursor, "White"],
            [colorBlackCursor, "Black"],
        ], 10, 290, canvas.width-20, 30, "Cursor Color", () => {
            renderMouseCursor = graphics => {
                cursorColor(graphics);
                cursorShape(graphics);
            }
            set_cursor(renderMouseCursor)
        });
    }

    iconFunction(canvas, graphics){
        graphics.fillStyle = '#646464';
        graphics.fillRect(0,0,canvas.width,canvas.height, 20);
        graphics.translate(canvas.width/2, canvas.height/2);
        var gearSizeCoefficient = 0.9;
        var scaledWidth = canvas.width * gearSizeCoefficient;
        var scaledHeight = canvas.height * gearSizeCoefficient;
        graphics.fillStyle = "white";
        graphics.ellipse(0,0,scaledWidth/1.5, scaledHeight/1.5, 0, 0, 0);
        //Spokes
        var spokeCount = 20;
        var spokeLengthOffset = 7;
        for(var i = 0; i < 360; i+=360/spokeCount){
            graphics.rotate(i * Math.PI / 180);
            graphics.fillRect(-(scaledWidth/spokeCount)/2, -scaledHeight/2 + spokeLengthOffset, scaledWidth/spokeCount, scaledHeight/2 - spokeLengthOffset, 10);
            graphics.rotate(-i * Math.PI / 180);
        }
        graphics.resetTransform();
    }

    create_window (){
        var settingsSystem = new Settings();
        quick_window((canvas,graphics) => {settingsSystem.update(canvas,graphics)}, "Settings");
    }
}//Survival of the Fittest
/* New features list:
x- Create shop icons
- Fix camera
- Make death screen more useful (with player stats, time alive, etc)
- Ability to aim (with right stick on controller)
- A boss every X rounds
- Fix controller bug where disconnecting just makes your character a potato
- Allow reliable joining mid-game (and have them be revived)
- Day/night cycle (and clouds)
*/
function customRandom(min, max) {
  return Math.random() * (max + Math.abs(min)) - Math.abs(min);
}
function fillPlayerNumber(number) {
  if (!number) {
    fill(170, 170, 170);
  } else {
    switch (number) {
      case 0:
        fill(170, 170, 170);
        break;
      case 1:
        fill(100, 100, 255);
        break;
      case 2:
        fill(255, 100, 100);
        break;
      case 3:
        fill(100, 255, 100);
        break;
      case 4:
        fill(255, 255, 100);
        break;
    }
  }
}
class SOTF {
  constructor() {
    this.players = [];
    this.enemies = [];
    this.world = [];
    this.guns = [];
    this.shopItems = [];

    this.menuState = "start";
    this.startupScreenTimer = 72;
    this.processes = [];
    this.logicProcesses = [];

    //gravityForce is measured in m/s
    //Every 20px is one meter ingame
    this.gravityForce = 9.8;
    this.playerSize = 30;
    this.enemySize = this.playerSize / 1.8;

    this.groundStepHeight = 0.2;
    this.groundStepWidth = 10;
    this.camX = 0;
    this.camY = 0;

    this.controllerDeadzone = 0.1;
    this.playerBuffer = [];
    this.deadPlayers = [];

    this.level = 1;
    this.levelKillGoal = 2;
    this.enemiesKilled = 0;
    this.transitionNextLevel = false;
    this.nextLevelTransitionCounter = 0;
    this.worldGenerationNumber = 0;
  }
  update(canvas, graphics) {
    let p5_environment = create_p5_environment(canvas, graphics);
    let rect = p5_environment.rect;
    let fill = p5_environment.fill;
    let self = this;

    //Guns
    function Gun() {
      this.name = '';
      this.art = () => { };
      this.damage = 0;
      this.spread = 0;
      this.special = false;
      this.automatic = false;
      this.fireCooldown = 0;
    }
    Gun.prototype.pistol = function () {
      this.name = 'pistol';
      this.art = direction => {
        //Do not stroke here;
        fill(50, 50, 50);
        if (direction === 'left') {
          translate(-self.playerSize / 2 + 2, self.playerSize / 2 - 6)
          rect(0, 0, 14, 6);
          rect(8, 5, 6, 7);
        }
        if (direction === 'right') {
          translate(self.playerSize - 1, self.playerSize / 2 - 6)
          rect(0, 0, 14, 6);
          rect(0, 5, 6, 7);
        }
        if (!direction) {
          rect(0, 0, 14, 6);
          rect(0, 5, 6, 7);
        }
      }
      this.damage = 15;
      this.spread = 20;
      this.special = false;
      this.automatic = false;
      this.fireCooldown = 0;
    }
    Gun.prototype.smg = function () {
      this.name = 'smg';
      this.art = direction => {
        //Do not stroke here;
        if (direction === 'left') {
          translate(-self.playerSize / 2 + 15, self.playerSize / 2 - 3);
          scale(0.6)
          fill(87, 76, 76);
          rect(0, 0, -50, 10);
          fill(110, 101, 101);
          rect(-30, 10, -7, 28);
          fill(176, 157, 157);
          rect(-50, 3, -5, 3);
          fill(112, 49, 0);
          rect(-5, 10, -8, 21);
        }
        if (direction === 'right') {
          translate(self.playerSize / 2 + 15, self.playerSize / 2 - 3);
          scale(0.6)
          fill(87, 76, 76);
          rect(0, 0, 50, 10);
          fill(110, 101, 101);
          rect(30, 10, 7, 28);
          fill(176, 157, 157);
          rect(50, 3, 5, 3);
          fill(112, 49, 0);
          rect(5, 10, 8, 21);
        }
        if (!direction) {
          fill(87, 76, 76);
          rect(0, 0, 50, 10);
          fill(110, 101, 101);
          rect(30, 10, 7, 28);
          fill(176, 157, 157);
          rect(50, 3, 5, 3);
          fill(112, 49, 0);
          rect(5, 10, 8, 21);
        }
      };
      this.damage = 13;
      this.automatic = true;
      this.special = false;
      this.fireRate = 17;
      this.spread = 30;
    }
    Gun.prototype.assault = function () {
      this.name = 'assault';
      this.art = direction => {
        //Do not stroke here;
        scale(0.5);
        if (direction === 'left') {
          translate(self.playerSize - 21, self.playerSize / 2 + 10);
          fill(30);
          rect(0, 0, -50, 10);
          fill(135, 71, 2);
          rect(-20, 10, -7, 20);
          fill(30);
          rect(-50, 1, -25, 7);
          fill(135, 71, 2);
          rect(-5, 10, -7, 15);
          rect(25, 0, -25, 6);
          rect(25, 0, -3, 20);
          fill(50);
          rect(-10, -4, -6, 4);
          fill(20);
          rect(-75, 3, -10, 3);
          rect(-85, 2, -6, 5);
        }
        if (direction === 'right') {
          translate(self.playerSize + 20, self.playerSize / 2 + 10);
          fill(30);
          rect(0, 0, 50, 10);
          fill(135, 71, 2);
          rect(20, 10, 7, 20);
          fill(30);
          rect(50, 1, 25, 7);
          fill(135, 71, 2);
          rect(5, 10, 7, 15);
          rect(-25, 0, 25, 6);
          rect(-25, 0, 3, 20);
          fill(50);
          rect(10, -4, 6, 4);
          fill(20);
          rect(75, 3, 10, 3);
          rect(85, 2, 6, 5);
        }
        if (!direction) {
          fill(30);
          rect(0, 0, 50, 10);
          fill(135, 71, 2);
          rect(20, 10, 7, 20);
          fill(30);
          rect(50, 1, 25, 7);
          fill(135, 71, 2);
          rect(5, 10, 7, 15);
          rect(-25, 0, 25, 6);
          rect(-25, 0, 3, 20);
          fill(50);
          rect(10, -4, 6, 4);
          fill(20);
          rect(75, 3, 10, 3);
          rect(85, 2, 6, 5);
        }
      };
      this.damage = 29;
      this.automatic = true;
      this.special = false;
      this.fireRate = 12;
      this.spread = 10;
    }
    Gun.prototype.shotgun = function () {
      this.name = 'shotgun';
      this.art = direction => {
        scale(0.5)
        stroke(0);
        if (direction === 'left') {
          translate(self.playerSize, self.playerSize / 2 + 10)
          fill(40);
          rect(0, 0, -48, 16);
          rect(-114, 1, 60, 5);
          rect(-48, 1, -19, 6);
          rect(-103, 9, 55, 5);
          rect(10, 0, -10, 30);
          fill(30);
          rect(-61, 6, -32, 11);
        }
        if (direction === 'right') {
          translate(self.playerSize, self.playerSize / 2 + 10)
          fill(40);
          rect(0, 0, 48, 16);
          rect(114, 1, -60, 5);
          rect(48, 1, 19, 6);
          rect(103, 9, -55, 5);
          rect(-10, 0, 10, 30);
          fill(30);
          rect(61, 6, 32, 11);
        }
        if (!direction) {
          fill(40);
          rect(0, 0, 48, 16);
          rect(114, 1, -60, 5);
          rect(48, 1, 19, 6);
          rect(103, 9, -55, 5);
          rect(-10, 0, 10, 30);
          fill(30);
          rect(61, 6, 32, 11);
        }
      };
      this.cost = 0;
      this.damage = 13;
      this.spread = 20;
      this.special = true;
    }
    Gun.prototype.sniper = function () {
      this.name = 'sniper';
      this.art = direction => {
        //Do not stroke here;
        scale(0.2);
        if (direction === 'left') {
          translate(self.playerSize - 30, self.playerSize / 2 + 50);
          fill(100);
          rect(0, 0, -200, 20);
          rect(-200, 7, -100, 7);
          rect(60, 0, -80, 6);
          rect(70, 0, -10, 30, 70, 0, 0, 0);
          fill(0);
          rect(-80, -17, -50, 18);
          rect(0, 20, -15, 20);
          rect(-60, 20, -10, 10);
          fill(70);
          rect(-300, 4, -15, 14);
        }
        if (direction === 'right') {
          translate(self.playerSize + 120, self.playerSize / 2 + 50);
          fill(100);
          rect(0, 0, 200, 20);
          rect(200, 7, 100, 7);
          rect(-60, 0, 80, 6);
          rect(-70, 0, 10, 30, 70, 0, 0, 0);
          fill(0);
          rect(80, -17, 50, 18);
          rect(0, 20, 15, 20);
          rect(60, 20, 10, 10);
          fill(70);
          rect(300, 4, 15, 14);
        }
        if (!direction) {
          fill(100);
          rect(0, 0, 200, 20);
          rect(200, 7, 100, 7);
          rect(-60, 0, 80, 6);
          rect(-70, 0, 10, 30, 70, 0, 0, 0);
          fill(0);
          rect(80, -17, 50, 18);
          rect(0, 20, 15, 20);
          rect(60, 20, 10, 10);
          fill(70);
          rect(300, 4, 15, 14);
        }
      }
      this.damage = 35;
      this.spread = 3;
      this.special = false;
      this.automatic = false;
      this.fireCooldown = 0;
    }

    //Player system
    function Player(x, y, controller, playerNumber) {
      this.x = x;
      this.y = y;
      this.health = 100;
      this.maxHealth = 100;

      this.controller = controller;
      this.number = 0;
      if (this.number !== undefined) {
        this.number = playerNumber;
      }

      this.shopButtonPressed = false;
      this.shopMenu = false;

      this.gravity = 0;
      this.horizontalVelocity = 0;
      this.speedMultiplier = 1;

      this.falling = true;
      this.jumping = false;

      this.gun = new Gun();
      this.gun.pistol();
      this.direction = 'left';
      this.gunFired = false;
      this.gunCooldownCounter = 0;
      this.gunShotCount = 0;
      this.shotMultiplier = 1;
      this.damageAdder = 0;

      this.damageDone = 0;
      this.points = 0;
      this.kills = 0;
    }
    //Function for shooting
    function findIntersection(x1, y1, x2, y2, x3, y3, x4, y4) {
      const denominator = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);
      if (denominator !== 0) {
        const t = ((x1 - x3) * (y3 - y4) - (y1 - y3) * (x3 - x4)) / denominator;
        const u = -((x1 - x2) * (y1 - y3) - (y1 - y2) * (x1 - x3)) / denominator;
        return (t > 0 && t < 1 && u > 0);
      } else {
        return false;
      }
    }
    function fireBullet(x, y, dirX, dirY, player) {
      var bulletHit = false;
      for (var i = 0; i < self.enemies.length; i++) {
        var currentEnemy = self.enemies[i];
        let bulletIntersects = false;

        const x3 = x;
        const y3 = y;
        const x4 = x + dirX;
        const y4 = y + dirY;
        //Left side
        var x1 = currentEnemy.x;
        var y1 = currentEnemy.y;
        var x2 = currentEnemy.x;
        var y2 = currentEnemy.y + self.enemySize;

        bulletIntersects = findIntersection(x1, y1, x2, y2, x3, y3, x4, y4);
        //Bottom side
        if (bulletIntersects === false) {
          x1 = currentEnemy.x;
          y1 = currentEnemy.y + self.enemySize;
          x2 = currentEnemy.x + self.enemySize;
          y2 = currentEnemy.y + self.enemySize;

          bulletIntersects = findIntersection(x1, y1, x2, y2, x3, y3, x4, y4);
        }
        //Right side
        if (bulletIntersects === false) {
          x1 = currentEnemy.x + self.enemySize;
          y1 = currentEnemy.y;
          x2 = currentEnemy.x + self.enemySize;
          y2 = currentEnemy.y + self.enemySize;

          bulletIntersects = findIntersection(x1, y1, x2, y2, x3, y3, x4, y4)
        }
        //Top side
        if (bulletIntersects === false) {
          x1 = currentEnemy.x;
          y1 = currentEnemy.y;
          x2 = currentEnemy.x + self.enemySize;
          y2 = currentEnemy.y;

          bulletIntersects = findIntersection(x1, y1, x2, y2, x3, y3, x4, y4);
        }
        if (bulletIntersects === true) {
          var playerDamage = player.gun.damage + player.damageAdder;
          player.damageDone += playerDamage;
          currentEnemy.health -= playerDamage;
          if (currentEnemy.health <= 0) {
            player.points++;
            player.kills++;
            self.enemiesKilled++;
            if (self.enemies.length <= Math.min(self.levelKillGoal - self.enemiesKilled, 1000)) {
              for (var l = 0; l <= Math.round(Math.random()) + 1; l++) {
                self.enemies.push(new Enemy(currentEnemy));
              }
            }
            self.enemies.splice(i, 1);
          }
          bulletHit = true;
        }
      }
      //Draw bullet
      if (bulletHit === false) {
        stroke(90, 90, 255);
      } else {
        stroke(255, 0, 0);
      }
      strokeWeight(3);
      line(x - self.camX, y - self.camY, (x - self.camX) + (dirX * canvas.width), (y - self.camY) + (dirY * canvas.height));
      //Do not stroke here;
      strokeWeight(1);
    }
    //Shop logic
    function ShopItem(cost, handler, compoundRate) {
      this.cost = cost;
      this.handler = handler;
      this.originalPrice = cost;
      this.compoundRate = compoundRate;
    }
    ShopItem.prototype.award = function (player) {
      if (player.points >= this.cost) {
        player.points -= this.cost;
        this.handler(player);
        if (this.compoundRate) {
          this.cost = Math.floor(this.cost * this.compoundRate);
        }
      }
    }
    ShopItem.prototype.resetPrice = function () {
      this.cost = this.originalPrice;
    }
    //Add shop items
    this.shopItems.push([
      new ShopItem(8, player => {
        if (player.health < player.maxHealth) {
          player.health += 20;
          if (player.health > player.maxHealth) {
            player.health = player.maxHealth
          }
        } else {
          player.points += 8;
        }
      })]);
    //Shop items
    this.shopItems.push([
      new ShopItem(12, player => { player.gun.smg(); }),//Up
      new ShopItem(100, player => { player.gun.assault(); }),//Right
      new ShopItem(400, player => { player.gun.shotgun(); }),//Down
      new ShopItem(1000, player => { player.gun.sniper(); }),//Left
    ]);
    this.shopItems.push([
      new ShopItem(50, player => { player.damageAdder++; }, 2.2),
      new ShopItem(130, player => { player.maxHealth += 10; player.health += 10; }, 1.5),
      new ShopItem(200, player => { player.speedMultiplier += 0.08; }, 1.9),
      new ShopItem(500, player => { player.shotMultiplier++; }, 2.8),
    ]);
    //Revive logic
    if (this.deadPlayers.length >= 1) {
      for (let i = 0; i < this.deadPlayers.length; i++) {
        this.shopItems[3][i] = new ShopItem(Math.floor(Math.pow(10, (self.level - 1) / 10 + 1)), () => {
          var currentDeadPlayer = self.deadPlayers[i];
          var newPlayerBody = new Player(self.camX + canvas.width / 2, self.camY - self.playerSize * 2, currentDeadPlayer.controller, currentDeadPlayer.number);
          newPlayerBody.kills = currentDeadPlayer.kills;
          newPlayerBody.damageDone = currentDeadPlayer.damageDone;
          newPlayerBody.points = Math.floor(currentDeadPlayer.points / 4);
          self.players.push(newPlayerBody);
          self.deadPlayers.splice(i, 1);
          self.shopItems[3].splice(i, 1);
        });
      }
    }


    function shopLogic(player, shopTrigger, upButton, downButton, leftButton, rightButton) {
      if (player.hasShop && shopTrigger) {
        player.shopOpened = true;
        if (!leftButton && !rightButton && !upButton && !downButton) {
          player.shopButtonPressed = false;
        }
        function shopButton(triggerButton, handler) {
          if (triggerButton && player.shopButtonPressed === false) {
            handler();
            player.shopButtonPressed = true;
          }
        }
        function shopLoop(index) {
          var currentShopGroup = self.shopItems[index];
          for (var i = 0; i < currentShopGroup.length; i++) {
            var shopTriggerButton;
            switch (i) {
              case 0:
                shopTriggerButton = upButton;
                break;
              case 1:
                shopTriggerButton = rightButton;
                break;
              case 2:
                shopTriggerButton = downButton;
                break;
              case 3:
                shopTriggerButton = leftButton;
                break;
            }
            shopButton(shopTriggerButton, () => { currentShopGroup[i].award(player); });
          }
        }
        if (player.shopMenu === "main") {
          shopButton(leftButton, () => { self.shopItems[0][0].award(player); });
          shopButton(upButton, () => { player.shopMenu = "revive"; });
          shopButton(rightButton, () => { player.shopMenu = "guns"; });
          shopButton(downButton, () => { player.shopMenu = "perks"; });
        }
        if (player.shopMenu === "guns") {
          shopLoop(1);
        }
        if (player.shopMenu === "guns2") {
          shopLoop(2);
        }
        if (player.shopMenu === "perks") {
          shopLoop(2);
        }
        if (player.shopMenu === "revive") {
          shopLoop(3);
        }
      } else {
        player.shopOpened = false;
        player.shopMenu = "main";
      }
    }
    //Update player logic
    let horizontalScreenEdgeDeadzone = 200;
    let verticalScreenEdgeDeadzone = canvas.height / 2 - (self.playerSize * 3);
    Player.prototype.update = function () {
      this.currentGravityForce = getTransition(self.gravityForce, 1000);
      let verticalMovementSpeed = this.currentGravityForce * 4;
      let playerMovementSpeed = this.currentGravityForce * 3 * this.speedMultiplier;
      if (!this.controller) {
        //Define control systems for internal use
        let devices = get_devices();
        this.keyboardShop = devices.keyboard.keyCodes[88];//X
        if (!(this.keyboardShop && this.hasShop)) {
          this.keyboardUp = devices.keyboard.keyCodes[38];
          this.keyboardDown = devices.keyboard.keyCodes[40];
          this.keyboardLeft = devices.keyboard.keyCodes[37];
          this.keyboardRight = devices.keyboard.keyCodes[39];
          this.keyboardShoot = devices.keyboard.keyCodes[90];//Z
        }

        if (this.falling) {
          this.gravity += this.currentGravityForce;
        } else if (!this.keyboardUp) {
          this.gravity = 0;
        }

        //Jumping
        if (this.keyboardUp && this.jumping === false) {
          this.gravity -= this.currentGravityForce * 60;
          this.jumpKeyReleased = false;
          this.jumping = true;
        }
        if (!this.keyboardUp && this.jumping === true) {
          this.jumpKeyReleased = true;
        }
        if (this.keyboardDown) {
          this.gravity += verticalMovementSpeed;
        }
        //Horizontal
        if (this.keyboardRight) {
          this.horizontalVelocity += playerMovementSpeed;
          this.direction = 'right';
        }
        if (this.keyboardLeft) {
          this.horizontalVelocity -= playerMovementSpeed;
          this.direction = 'left';
        }

        shopLogic(this, this.keyboardShop, devices.keyboard.keyCodes[38], devices.keyboard.keyCodes[40], devices.keyboard.keyCodes[37], devices.keyboard.keyCodes[39]);
      }
      if (this.controller) {
        //Define control systems for internal use
        this.controllerShop = this.controller.buttons[4].pressed;//L1
        this.controllerUp = this.controller.buttons[0].pressed;//X
        this.controllerLeftStickY = this.controller.axes[1];//Right-down stick
        this.controllerLeftStickX = this.controller.axes[0];
        this.controllerShoot = this.controller.buttons[3].pressed;//Square

        if (this.falling) {
          this.gravity += this.currentGravityForce;
        } else if (!this.controllerUp) {
          this.gravity = 0;
        }

        //Jumping
        if (this.controllerUp && this.jumping === false) {
          this.gravity -= this.currentGravityForce * 60;
          this.jumpKeyReleased = false;
          this.jumping = true;
        }
        if (!this.controllerUp && this.jumping === true) {
          this.jumpKeyReleased = true;
        }
        if (this.controllerLeftStickY > 0.9) {
          this.gravity += verticalMovementSpeed;
        }
        //Horizontal
        if (Math.abs(this.controllerLeftStickX) > self.controllerDeadzone) {
          this.horizontalVelocity += playerMovementSpeed * this.controllerLeftStickX;
          this.direction = 'left';
          if (this.controllerLeftStickX > 0) {
            this.direction = 'right';
          }
        }

        shopLogic(this, this.controllerShop, (this.controller.axes[7] < 0), (this.controller.axes[7] > 0), (this.controller.axes[6] < 0), (this.controller.axes[6] > 0));
      }
      this.horizontalVelocity = this.horizontalVelocity / 1.06;

      //Prevent player from going off screen
      var screenDeadzone = 10;
      if (this.x - self.camX <= screenDeadzone) {
        this.x += self.camX - (this.x - screenDeadzone);
      }
      if (this.x + self.playerSize - self.camX >= canvas.width - screenDeadzone) {
        this.x += (self.camX + (canvas.width - screenDeadzone)) - (this.x + self.playerSize);
      }
      if (this.y - self.camY <= screenDeadzone) {
        this.y += self.camY - (this.y - screenDeadzone);
      }
      if (this.y + self.playerSize - self.camY >= canvas.height - screenDeadzone) {
        this.y += (self.camY + (canvas.height - screenDeadzone)) - (this.y + self.playerSize);
      }

      //Apply gravities
      this.y += this.gravity;
      this.x += this.horizontalVelocity;
    }
    Player.prototype.shoot = function () {
      //Shooting
      if (this.keyboardShoot || this.controllerShoot) {
        if (self.menuState === "game") {
          var shotDirection = 1;
          if (this.direction === 'left') {
            shotDirection = -1;
          }
          if (this.gun.special === false) {
            if (this.gun.automatic === false && this.gunFired === false) {
              for (var i = 0; i < this.shotMultiplier; i++) {
                fireBullet(this.x + self.playerSize / 2, this.y + self.playerSize / 2, shotDirection, customRandom(-this.gun.spread / 100, this.gun.spread / 100), this);
              }
              this.gunFired = true;
            }
            if (this.gun.automatic === true) {
              this.gunCooldownCounter += getAnimationExpansionRate(this.gun.fireRate, 1000);
              if (this.gunShotCount <= this.gunCooldownCounter) {
                for (var i = 0; i < this.shotMultiplier; i++) {
                  fireBullet(this.x + self.playerSize / 2, this.y + self.playerSize / 2, shotDirection, customRandom(-this.gun.spread / 100, this.gun.spread / 100), this);
                }
                this.gunShotCount++;
              }
            }
          } else {
            if (this.gun.name === "shotgun" && this.gunFired === false) {
              for (var i = 0; i < 8 + (this.shotMultiplier - 1); i++) {
                fireBullet(this.x + self.playerSize / 2, this.y + self.playerSize / 2, shotDirection, customRandom(-this.gun.spread / 100, this.gun.spread / 100), this);
              }
              this.gunFired = true;
            }
          }
        }
      } else {
        this.gunFired = false;
        this.gunCooldownCounter = 0;
        this.gunShotCount = 0;
      }
    }
    Player.prototype.moveCamera = function () {
      //Move camera when approaching the end of the screen
      if (this.x - self.camX + self.playerSize + this.horizontalVelocity > canvas.width - horizontalScreenEdgeDeadzone) {
        self.camX += (this.x - self.camX + self.playerSize) - (canvas.width - horizontalScreenEdgeDeadzone);
      }
      if (this.x - self.camX + this.horizontalVelocity < horizontalScreenEdgeDeadzone) {
        self.camX += (this.x - self.camX) - horizontalScreenEdgeDeadzone;
      }
      if (this.y - self.camY + self.playerSize + this.gravity > canvas.height - verticalScreenEdgeDeadzone) {
        self.camY += (this.y - self.camY + self.playerSize) - (canvas.height - verticalScreenEdgeDeadzone);
      }
      if (this.y - self.camY + this.gravity < verticalScreenEdgeDeadzone) {
        self.camY += (this.y - self.camY) - verticalScreenEdgeDeadzone;
      }
    }
    Player.prototype.updateWorld = function () {
      //Deal with world interaction
      var fallingVariableBuffer = true;
      var hasShopBuffer = false;
      for (var i = -1; i < Math.floor(self.playerSize / self.groundStepWidth + 2); i++) {
        let currentWorld = self.world[Math.abs(i + Math.floor(this.x / self.groundStepWidth))];
        if (currentWorld) {
          let currentWorldLevel = currentWorld[0];
          let currentWorldLevelX = Math.floor(this.x / self.groundStepWidth + i) * self.groundStepWidth;
          //Deal with collisions
          if (this.y + self.playerSize + 1 > currentWorldLevel && this.x + self.playerSize > currentWorldLevelX && this.x < currentWorldLevelX + self.groundStepWidth) {
            fallingVariableBuffer = false;
            if (this.jumpKeyReleased === true) {
              this.jumping = false;
            }
            if (self.playerSize / 5 + this.gravity > this.y + self.playerSize + 1 - currentWorldLevel) {
              this.y = currentWorldLevel - self.playerSize;
            } else {
              if (this.horizontalVelocity > 0 && this.x + self.playerSize > currentWorldLevelX) {
                this.x = currentWorldLevelX - self.playerSize - this.horizontalVelocity;
                this.horizontalVelocity = 0;
              }
              if (this.horizontalVelocity < 0 && this.x < currentWorldLevelX + self.groundStepWidth) {
                this.x = currentWorldLevelX + self.groundStepWidth - this.horizontalVelocity;
                this.horizontalVelocity = 0;
              }
            }
          }
          if (this.y > currentWorldLevel) {
            this.y = currentWorldLevel - self.playerSize;
          }
          if (currentWorld[1] === true) {
            hasShopBuffer = true;
          }
        }
      }
      this.hasShop = hasShopBuffer;
      this.falling = fallingVariableBuffer;
    }
    //Draw player
    Player.prototype.draw = function () {
      if (this.x - self.camX >= 0 && this.y - self.camY >= 0 && this.x - self.camX + self.playerSize <= canvas.width && this.y - self.camY + self.playerSize <= canvas.height) {
        graphics.save();
        stroke(0);
        fill(255, 50, 50);
        translate(this.x - self.camX, this.y - self.camY);
        rect(0, -10, this.health / this.maxHealth * self.playerSize, 5);
        fillPlayerNumber(this.number);
        rect(0, 0, self.playerSize, self.playerSize);

        if (this.shopOpened === true) {
          //Shop menu
          graphics.save();
          var shopScale = 1.3;
          translate(self.playerSize / 2, -65 * shopScale);
          scale(shopScale);
          fill(230, 230, 230);
          ellipse(0, 0, 70, 70);
          stroke(0);
          line(-20, -20, 20, 20);
          line(20, -20, -20, 20);
          textSize(10);
          var thisPlayer = this;
          var displayGun = new Gun();
          function displayPrice(price, side) {
            if (thisPlayer.points < price) {
              fill(255, 70, 70);
            } else {
              fill(0, 225, 0);
            }
            var textAlignment;
            switch (side) {
              case 'left':
                textAlignment = [-51, 5];
                break;
              case 'right':
                textAlignment = [51, 5];
                break;
              case 'bottom':
                textAlignment = [0, 47];
                break;
              case 'top':
                textAlignment = [0, -44];
                break;
            }
            simpleCenterText("$" + price, textAlignment[0], textAlignment[1]);
          }
          if (this.shopMenu === "main") {
            //Health
            //Do not stroke here;
            displayPrice(self.shopItems[0][0].cost, 'left');
            fill(255, 30, 30);
            rect(-22.5, 0, 5, 5);
            rect(-19.5, -3.5, 5, 5);
            rect(-25.5, -3.5, 5, 5);

            //Perks
            fill(10, 90, 255);
            rect(-7.5, 17, 17, 6);
            rect(-2, 12, 6, 16);

            //Gun
            graphics.save();
            translate(13, -11 / 2);
            displayGun.pistol();
            displayGun.art();
            graphics.restore();

            //Revive
            fill(70, 200, 70)
            triangle(0, -28, 8, -21, -8, -21);
            rect(-4, -23, 8, 10, 2);

          }
          function displayShopPrices(shopItemList) {
            //Do not stroke here;
            for (var i = 0; i < shopItemList.length; i++) {
              var displaySide;
              switch (i) {
                case 0:
                  displaySide = "top";
                  break;
                case 1:
                  displaySide = "right";
                  break;
                case 2:
                  displaySide = "bottom";
                  break;
                case 3:
                  displaySide = "left";
                  break;
              }
              displayPrice(shopItemList[i].cost, displaySide);
            }
          }
          if (this.shopMenu === "guns") {
            //SMG
            graphics.save();
            translate(-12, -28);
            scale(0.5);
            displayGun.smg();
            displayGun.art();
            graphics.restore();

            //Assault Rifle
            graphics.save();
            translate(11, -2);
            scale(0.48);
            displayGun.assault();
            displayGun.art();
            graphics.restore();

            //Shotgun
            graphics.save();
            translate(-10, 17);
            scale(0.4);
            displayGun.shotgun();
            displayGun.art();
            graphics.restore();

            //Sniper
            graphics.save();
            translate(-28, -1);
            scale(0.5);
            displayGun.sniper();
            displayGun.art();
            graphics.restore();

            displayShopPrices(self.shopItems[1]);
          }
          if (this.shopMenu === "perks") {
            graphics.save();
            //Bullet damage
            scale(0.5);
            //Do not stroke here;
            graphics.save();
            translate(-18, -50);
            fill(125, 125, 125);
            rect(12,0,11,10,10);
            rect(0,0,18,10,1);

            fill(255, 64, 64);
            var xOffset = 23;
            var yOffset = 1;
            rect(-5.5 + xOffset, 17 + yOffset, 17, 6);
            rect(0 + xOffset, 12 + yOffset, 6, 16);
            graphics.restore();

            //More max health
            graphics.save();
            translate(35, 0);
            scale(2);
            //Do not stroke here;
            fill(255, 200, 40);
            rect(0, 0, 5, 5);
            rect(3, -3.5, 5, 5);
            rect(-3, -3.5, 5, 5);
            graphics.restore();

            //Speed
            graphics.save();
            translate(-14, 30);
            scale(0.7);
            fill(40, 220, 225);
            stroke(0);

            beginShape();
            vertex(0,-5);
            vertex(20,-5);
            vertex(16,-15);
            vertex(34,0);
            vertex(16,15);
            vertex(20,5);
            vertex(0,5);
            vertex(0,-5);
            endShape();

            translate(17,26);
            
            beginShape();
            vertex(0,-5);
            vertex(20,-5);
            vertex(16,-15);
            vertex(34,0);
            vertex(16,15);
            vertex(20,5);
            vertex(0,5);
            vertex(0,-5);
            endShape();
            graphics.restore();

            //More Bullets
            graphics.save();
            translate(-60, -13);
            fill(125, 125, 125);
            rect(12,0,11,10,10);
            rect(0,0,18,10,1);

            rect(21,17,11,10,10);
            rect(9,17,18,10,1);
            graphics.restore();

            graphics.restore();

            displayShopPrices(self.shopItems[2]);
          }
          if (this.shopMenu === "revive") {
            for (var i = 0; i < self.deadPlayers.length; i++) {
              graphics.save();
              switch (i) {
                case 0:
                  displayPrice(self.shopItems[3][i].cost, 'top');
                  translate(0, -20);
                  break;
                case 1:
                  displayPrice(self.shopItems[3][i].cost, 'right');
                  translate(20, 0);
                  break;
                case 2:
                  displayPrice(self.shopItems[3][i].cost, 'bottom');
                  translate(0, 20);
                  break;
                case 3:
                  displayPrice(self.shopItems[3][i].cost, 'left');
                  translate(-20, 0);
                  break;
              }
              fillPlayerNumber(self.deadPlayers[i].number);
              rect(-8, -8, 16, 16);
              graphics.restore();
            }
          }
          graphics.restore();
        } else if (this.hasShop === true) {
          //Shop hint
          fill(255);
          //Do not stroke here;
          textSize(16);
          if (this.controller) {
            simpleCenterText("Hold L1 to open the shop", self.playerSize / 2, -20);
          } else {
            simpleCenterText("Hold X to open the shop", self.playerSize / 2, -20);
          }
        }

        this.gun.art(this.direction);
        graphics.restore();
      }
    }
    //Enemies
    function Enemy(enemy) {
      if (enemy !== undefined) {
        this.x = enemy.x + customRandom(-self.enemySize * 2, self.enemySize * 2);
        this.y = enemy.y - 2;
        this.gravity = enemy.gravity;
        this.horizontalVelocity = enemy.horizontalVelocity;
      } else {
        this.x = self.camX + Math.random() * canvas.width;
        this.y = -self.enemySize + self.camY;
        this.gravity = 0;
        this.horizontalVelocity = 0;
      }

      this.health = 100;

      this.falling = true;
      this.geneticVariation = Math.random() + 0.5;
    }
    //Update enemy world interaction logic
    Enemy.prototype.updateWorld = function () {
      //Deal with ground collision and jumping
      var fallingVariableBuffer = true;
      var verticalMovementSpeed = self.enemySize / 5;
      for (var i = -1; i < Math.floor(self.enemySize / self.groundStepWidth + 2); i++) {
        let currentWorld = self.world[Math.abs(i + Math.floor(this.x / self.groundStepWidth))];
        if (currentWorld) {
          let currentWorldLevel = currentWorld[0];
          let currentWorldLevelX = Math.floor(this.x / self.groundStepWidth + i) * self.groundStepWidth;
          //Deal with collisions
          if (this.y + self.enemySize + 1 > currentWorldLevel && (this.x + self.enemySize) > currentWorldLevelX && (this.x) < currentWorldLevelX + self.groundStepWidth) {
            fallingVariableBuffer = false;
            if ((this.y + self.enemySize + 1 - currentWorldLevel) < self.enemySize / 5 + this.gravity) {
              this.y = currentWorldLevel - self.enemySize;
            } else {
              if (this.horizontalVelocity > 0 && this.x + self.enemySize > currentWorldLevelX) {
                this.x = currentWorldLevelX - self.enemySize;
                this.horizontalVelocity = 0;
                this.gravity -= verticalMovementSpeed * this.geneticVariation;
                this.jumping = true;
              }
              if (this.horizontalVelocity < 0 && this.x < currentWorldLevelX + self.groundStepWidth) {
                this.x = currentWorldLevelX + self.groundStepWidth;
                this.horizontalVelocity = 0;
                this.gravity -= verticalMovementSpeed * this.geneticVariation;
                this.jumping = true;
              }
            }
          }
        } else {
          this.suspend = true;
        }
      }
      this.falling = fallingVariableBuffer;
    }
    //Update enemy logic
    Enemy.prototype.update = function () {
      var enemyMovementSpeed = getTransition((100 / Math.max(5, this.health)) + (self.gravityForce * 1.2 + (this.geneticVariation * 3 - 1.5)), 1000);
      if (this.suspend === false) {
        let currentGravityForce = getTransition(self.gravityForce, 1000);
        if (this.falling) {
          this.gravity += currentGravityForce;
        } else if (!this.jumping) {
          this.gravity = 0;
        }
        this.jumping = false;

        //Find nearest player to target
        var leastPlayerDistance = Infinity;
        let targetPlayer;
        for (var i = 0; i < self.players.length; i++) {
          var currentPlayer = self.players[i];
          var playerDistance = Math.abs(this.x - currentPlayer.x) + Math.abs(this.y - currentPlayer.y);
          if (playerDistance < leastPlayerDistance) {
            leastPlayerDistance = playerDistance;
            targetPlayer = currentPlayer;
          }
        }
        if (!targetPlayer) {
          targetPlayer = new Player(this.x, 0);
        }

        //Horizontal
        if (this.x < targetPlayer.x + self.playerSize / 2 - self.enemySize / 2) {
          this.horizontalVelocity += enemyMovementSpeed;
        } else {
          this.horizontalVelocity -= enemyMovementSpeed;
        }
        this.horizontalVelocity = this.horizontalVelocity / 1.06;

        //Apply gravities
        this.y += this.gravity;
        this.x += this.horizontalVelocity;
      }
      this.suspend = false;
    }
    Enemy.prototype.draw = function () {
      if (this.x - self.camX > 0 && this.y - self.camY > 0 && this.x - self.camX + self.enemySize < canvas.width && this.y - self.camY + self.enemySize < canvas.height) {
        fill(255, (this.health / 100) * 130, (this.health / 100) * 130);
        rect(this.x - self.camX, this.y - self.camY, self.enemySize, self.enemySize);
      }
    }
    self.world[0] = [canvas.height / 2, false, false];

    //Menu system
    if (this.menuState === "start") {
      fill(150, 205, 150);
      rect(0, 0, canvas.width, canvas.height);

      fill(0);
      centerText("SOTF", canvas.width / 2 - 20, canvas.height / 2 - 20, 40, 40, 75);
      this.startupScreenTimer -= getAnimationExpansionRate(72, 2500);
      if (this.startupScreenTimer <= 0) {
        this.menuState = "menu";
      }
    }
    if (this.menuState === "menu") {
      fill(127);
      rect(0, 0, canvas.width, canvas.height);
      fill(255);
      centerText("Survival of the Fittest", canvas.width / 2 - 20, 30, 40, 40, 75);

      //Start Game button
      function singlePlayerMenuState() {
        self.menuState = "game";
        resumeSystem(self.logicProcesses, true);
        self.players.push(new Player(canvas.width / 2, 60));
        self.enemies.push(new Enemy());
      }
      function multiplayerMenuState() {
        self.menuState = "multiplayer";
      }
      fill(30);
      labledButton(100, 150, canvas.width - 200, 100, singlePlayerMenuState, "Single Player", 30);
      fill(30);
      labledButton(100, 300, canvas.width - 200, 100, multiplayerMenuState, "Multiplayer", 30);
    }
    if (this.menuState === "multiplayer") {
      fill(127);
      rect(0, 0, canvas.width, canvas.height);
      fill(255);
      centerText("To join, press X on your controller.", canvas.width / 2 - 20, 50, 40, 40, 32);
      function startMultiplayerGame() {
        self.players = self.playerBuffer;
        self.menuState = "game";
        resumeSystem(self.logicProcesses, true);
        for (var i = 0; i < self.playerBuffer.length; i++) {
          self.enemies.push(new Enemy());
        }
        self.levelKillGoal = self.levelKillGoal * self.playerBuffer.length;
        self.playerBuffer = [];
      }
      if (this.playerBuffer.length > 0) {
        labledButton(100, 400, canvas.width - 200, 40, startMultiplayerGame, "All players are ready", 20);
      }
      for (var i = 0; i < controllerArray.length; i++) {
        if (controllerArray[i].buttons[0].pressed) {
          var controllerHasPlayer = false;
          for (var l = 0; l < this.playerBuffer.length; l++) {
            if (controllerArray[i].index === this.playerBuffer[l].controller.index) {
              controllerHasPlayer = true;
            }
          }
          if (controllerHasPlayer === false) {
            this.playerBuffer.push(new Player(canvas.width / 2, 60, controllerArray[i], this.playerBuffer.length));
          }
        }
        if (controllerArray[i].buttons[1].pressed) {
          for (var l = 0; l < this.playerBuffer.length; l++) {
            if (controllerArray[i].index === this.playerBuffer[l].controller.index) {
              this.playerBuffer.splice(l, 1);
              for (var x = 0; x < this.playerBuffer.length; x++) {
                this.playerBuffer[x].number = x;
              }
            }
          }
        }
      }
      for (let i = 0; i < this.playerBuffer.length; i++) {
        graphics.save();
        fillPlayerNumber(this.playerBuffer[i].number);
        if (this.playerBuffer[i].controller.buttons[0].pressed) {
          fill(255);
        }
        rect(200 + (canvas.width - 200) * (i / this.playerBuffer.length), 200, self.playerSize, self.playerSize);
        blankButton(200 + (canvas.width - 200) * (i / this.playerBuffer.length), 200, self.playerSize, self.playerSize, () => {
          self.playerBuffer.splice(i, 1);
        });
        graphics.restore();
      }
    }

    if (this.transitionNextLevel === true) {
      this.nextLevelTransitionCounter += getAnimationExpansionRate(1, 1000);
      var timeLeft = (3 - floor(this.nextLevelTransitionCounter));
      if (timeLeft <= 0) {
        this.levelKillGoal = Math.round(this.levelKillGoal * 1.5);
        this.enemiesKilled = 0;
        this.level++;
        for (var i = 0; i < this.level * this.players.length; i++) {
          this.enemies.push(new Enemy());
        }
        this.levelFinished = false;
        this.transitionNextLevel = false;
        this.nextLevelTransitionCounter = 0;
      } else {
        graphics.save();
        fill(50, 155, 50);
        centerText("Level Complete!", canvas.width / 2 - 40, 100, 40, 40, 20);
        fill(35);
        textSize(18)
        text("Next level beginning in " + timeLeft + " seconds...", 100, 100);
        graphics.restore();
      }
    }

    if (this.menuState === "no players") {
      //Start Game button
      function revertMenuState() {
        self.menuState = "menu";
        self.world = [];
        self.enemies = [];
        self.players = [];
        self.deadPlayers = [];
        self.level = 1;
        self.camX = 0;
        self.camY = 0;
        self.levelKillGoal = 2;
        self.enemiesKilled = 0;
        for (var i = 0; i < self.shopItems.length; i++) {
          for (var l = 0; l < self.shopItems[i].length; l++) {
            self.shopItems[i][l].resetPrice();
          }
        }
        suspendSystem(self.logicProcesses, true);
      }
      graphics.save();
      fill(255, 0, 0);
      centerText("Loser Cruiser", canvas.width / 2 - 20, 100, 40, 40, 40);

      fill(30);
      Button(canvas.width / 2 - 150, canvas.height / 2 - 100, 300, 200, revertMenuState);
      fill(255)
      centerText("Main Menu", canvas.width / 2 - 20, canvas.height / 2 - 20, 40, 40, 20);
      graphics.restore();
    }
  }
  updateGameProcesses() {
    if (this.menuState === "game") {
      updateProcesses(this.processes);
    }
  }
  updateLogic() {
    if (this.enemiesKilled >= Math.round(this.levelKillGoal) && this.menuState === "game" && this.transitionNextLevel === false) {
      this.transitionNextLevel = true;
      this.enemies = [];
      for (var i = 0; i < this.players.length; i++) {
        this.players[i].health += 15;
        if (this.players[i].health > this.players[i].maxHealth) {
          this.players[i].health = this.players[i].maxHealth;
        }
        this.players[i].points += this.level;
      }
    }
    if (this.players.length === 0) {
      this.menuState = "no players";
    }
  }
  create_window(mode) {
    var self = new SOTF();
    //Functions for updating game mechanics
    function drawPlayers() {
      graphics.save();
      for (var i = self.players.length - 1; i >= 0; i--) {
        self.players[i].moveCamera();
        self.players[i].draw();
      }
      graphics.restore();
    }
    function updatePlayers() {
      for (var i = 0; i < self.players.length; i++) {
        self.players[i].updateWorld();
        self.players[i].update();
      }
    }
    function updatePlayerShooting() {
      for (var i = 0; i < self.players.length; i++) {
        self.players[i].shoot();
      }
    }
    function drawEnemies() {
      graphics.save();
      stroke(0);
      for (var i in self.enemies) {
        self.enemies[i].draw();
      }
      graphics.restore();
    }
    function updateEnemies() {
      for (var i = 0; i < self.enemies.length; i++) {
        self.enemies[i].updateWorld();
        self.enemies[i].update();
        if (self.enemies.dead === true) {
          self.enemies.splice(i, 1);
        }
      }
    }
    function updateEnemyPlayerCollisions() {
      for (var i = 0; i < self.players.length; i++) {
        var currentPlayer = self.players[i];
        for (var l = 0; l < self.enemies.length; l++) {
          var currentEnemy = self.enemies[l];
          if (currentEnemy.x + self.enemySize > currentPlayer.x && currentEnemy.x < currentPlayer.x + self.playerSize && currentEnemy.y + self.playerSize > currentPlayer.y && currentEnemy.y < currentPlayer.y + self.playerSize) {
            currentPlayer.health -= getTransition(100, 5000);
          }
        }
        if (currentPlayer.health < 0) {
          self.deadPlayers.push(self.players[i]);
          self.players.splice(i, 1);
        }
      }
    }
    function capEnemyCount() {
      if (self.enemies.length > self.levelKillGoal - self.enemiesKilled && self.enemies.length > 0) {
        for (var i = self.enemies.length; i >= Math.min(self.levelKillGoal - self.enemiesKilled, 1000); i--) {
          self.enemies.splice(i, 1);
        }
      }
    }
    //World Generation
    function generateWorld() {
      var newGenerationHeight;
      var generationOverscan = (60 / self.groundStepWidth);
      for (var i = 1; i < canvas.width / self.groundStepWidth + generationOverscan * 2; i++) {
        var worldIndex = Math.abs(i + Math.floor(self.camX / self.groundStepWidth - generationOverscan));
        if (!self.world[worldIndex]) {
          if (worldIndex !== 0) {
            let previousWorld = self.world[worldIndex - 1];
            for (var l = 1; previousWorld === undefined; l++) {
              previousWorld = self.world[worldIndex - l];
            }
            if (self.worldGenerationNumber > 0) {
              self.worldGenerationNumber = Math.min(self.groundStepHeight * 15, self.worldGenerationNumber + customRandom(-self.groundStepHeight, self.groundStepHeight));
            } else {
              self.worldGenerationNumber = Math.max(-(self.groundStepHeight * 15), self.worldGenerationNumber + customRandom(-self.groundStepHeight, self.groundStepHeight));
            }
            newGenerationHeight = previousWorld[0] + self.worldGenerationNumber;
          }
          //World Features: [y, hasShop, hasFlower]
          self.world[worldIndex] = [newGenerationHeight, (Math.random() < 0.005), (Math.random() < 0.08)];
        }
      }
    }
    function renderWorld() {
      graphics.save();
      //Do not stroke here;
      fill(100, 255, 100);
      var adjustedCamX = self.camX / self.groundStepWidth;
      for (var i = Math.floor(adjustedCamX); i < canvas.width / self.groundStepWidth + adjustedCamX; i++) {
        let worldBlock = self.world[Math.abs(i)];
        if (worldBlock) {
          translate(i * self.groundStepWidth - self.camX, worldBlock[0] - self.camY);
          rect(0, 0, self.groundStepWidth, Math.max(canvas.height - (worldBlock[0] - self.camY), 0));
          if (worldBlock[2] === true) {
            fill(100, 255, 100);
            rect(self.groundStepWidth / 2 - 1, -3, 2, 3);
            fill(255, 0, 240);
            rect(self.groundStepWidth / 2 - 2.5, -8, 5, 5);
            fill(100, 255, 100);
          }
          if (worldBlock[1] === true) {
            graphics.save();
            scale(0.5);
            translate(0, -148);
            fill(210, 40, 40);
            triangle(0, 69, 0, 0, 81, 69);
            fill(220);
            rect(0, 68, 80, 80);
            fill(50, 50, 255)
            rect(54, 72, 20, 20);
            rect(5, 72, 20, 20);
            rect(5, 37, 20, 20);
            rect(25, 102, 30, 46);
            fill(127, 127, 127);
            ellipse(50, 122, 5, 5);
            graphics.restore();
          }
          translate(-(i * self.groundStepWidth - self.camX), -(worldBlock[0] - self.camY));
        }
      }
      graphics.restore();
    }
    function renderHud() {
      graphics.save();
      var hudScale = 1.5;
      graphics.scale(hudScale);
      fill(100);
      rect(canvas.width / 2, 0, canvas.width / 2, 20);

      fill(255);
      textSize(12);
      text("Level: " + self.level, canvas.width / 2 + 6, 14);
      text("Enemies Left: " + Math.max(self.levelKillGoal - self.enemiesKilled, 0), canvas.width / 2 + 70, 14);

      //Scoreboard
      //Do not stroke here;
      for (var i = 0; i < self.players.length; i++) {
        var currentPlayer = self.players[i];
        fillPlayerNumber(currentPlayer.number);
        rect(canvas.width - 200, 20 * i, 200, 20);
        fill(0);
        var killMessage = currentPlayer.kills + " kills | ";
        if (currentPlayer.kills === 1) {
          killMessage = currentPlayer.kills + " kill | ";
        }
        text("$" + currentPlayer.points + " | " + killMessage + currentPlayer.damageDone + " damage", canvas.width - 195, 14 + (20 * i));
      }
      graphics.restore();
    }
    function updateGameLogic() {
      self.updateLogic();
    }
    function drawBackground() {
      //Sky
      var resolutionScale = 30;
      //Do not stroke here;
      for (var i = 0; i < canvas.height; i += resolutionScale) {
        var scaledBackground = i * (255 / canvas.height);
        fill(100 + scaledBackground, 150, 255 - scaledBackground / 4);
        rect(0, i, canvas.width, resolutionScale + 1);
      }
      //Clouds

      /* Emo black background
      fill(0, 0, 0);
      rect(0, 0, canvas.width, canvas.height);
      */
    }
    function updateGame() {
      self.update();
    }
    function sotf_logic_update(){
      createThread(generateWorld);
      createThread(capEnemyCount);
      createThread(updateEnemies);
      createThread(updatePlayers);
      createThread(updateEnemyPlayerCollisions);
      createThread(generateWorld);
    }
    let logic_process = spawn_process(sotf_logic_update);
    
    //Processes
    // let logicProcesses = [
    //   //World
    //   spawn_process(generateWorld, 0),
    //   //Enemies
    //   spawn_process(capEnemyCount, 2),
    //   spawn_process(updateEnemies, 1, self.logicProcesses),
    //   //Players
    //   spawn_process(updatePlayers, 4, self.logicProcesses),
    //   //Update player-enemy collissions
    //   spawn_process(updateEnemyPlayerCollisions, 0, self.logicProcesses),
    //   //Game logic (levels)
    //   spawn_process(updateGameLogic, 2, self.logicProcesses),
    // ]
    function sotf_graphics_update(){
      createThread(drawBackground)
      createThread(renderWorld)
      createThread(drawEnemies)
      createThread(updatePlayerShooting)
      createThread(drawPlayers)
      createThread(renderHud)
      createThread(updateGame)
    }

    //Create processes to pass into the window manager
    // let windowProcesses = [
    //   spawn_process(drawBackground, 1),
    //   spawn_process(renderWorld, 0),
    //   spawn_process(drawEnemies, -3),
    //   spawn_process(updatePlayerShooting, 2),
    //   spawn_process(drawPlayers, 2),
    //   spawn_process(renderHud, 1),
    //   spawn_process(updateGame, 3),
    // ]

    if (mode === "fullscreen") {
      var sotfWindow = spawn_window("Survival of the Fittest", windowProcesses, false, self.logicProcesses);
      sotfWindow.x = canvas.width / 2;
      sotfWindow.y = canvas.height / 2;
      sotfWindow.targetWidth = canvas.width;
      sotfWindow.targetHeight = canvas.height;
      windows.push(sotfWindow);
    } else if(mode === "standalone"){
      push_process()
      addProcessGroup(self.logicProcesses);
    }else {
      //Add game processes to the window manager
      var sotfWindow = spawn_window(windowProcesses, "Survival of the Fittest");
      sotfWindow.maximize = true;
      sotfWindow.initProcesses();
      windows.push(sotfWindow);
    }
    suspendSystem(self.logicProcesses, true);
  }
  iconFunction(canvas, graphics) {
    graphics.fillStyle = "#50c850";
    graphics.fillRect(0, 0, canvas.width, canvas.height, 3);
    graphics.fillStyle = "white";
    graphics.font = (canvas.width / 5) + "pt Arial";
    graphics.fillText("SOTF", canvas.width / 10, canvas.height / 2.5);
    graphics.fillRect(canvas.width / 10, canvas.height * 0.7, canvas.width * 0.8, canvas.height / 5);
  }
}
/* Octane game engine */

class Octane{
    constructor(){
        this.objects = [];
        
        this.canvas = document.createElement("canvas");
        this.canvas.width = this.width;
        this.canvas.height = this.height;
        this.graphics = this.canvas.getContext('2d');
    }
    update(canvas, graphics){

        class Object{
            constructor(){
                this.x = 0;
                this.y = 0;
            }
            shade(){

            }
        }

        //GUI
        graphics.fillStyle = "#7777FF";
        graphics.fillRect(0, 0, canvas.width, canvas.height);
    }
    iconFunction(canvas,graphics){
        graphics.fillStyle = '#AA22FF';
        graphics.fillRect(0,0,canvas.width,canvas.height, 20);
        graphics.translate(canvas.width/2, canvas.height/2);
        var gearSizeCoefficient = 0.9;
        var scaledWidth = canvas.width * gearSizeCoefficient;
        var scaledHeight = canvas.height * gearSizeCoefficient;
        graphics.fillStyle = "black";
        graphics.ellipse(0,0,scaledWidth/1.5, scaledHeight/1.5, 0, 0, 0);
        //Spokes
        var spokeCount = 8;
        var spokeLengthOffset = 0;
        for(var i = 0; i < 360; i+=360/spokeCount){
            graphics.rotate(i * Math.PI / 180);
            graphics.fillRect(-(scaledWidth/spokeCount)/2, -scaledHeight/2 + spokeLengthOffset, scaledWidth/spokeCount, scaledHeight/2 - spokeLengthOffset, 10);
            graphics.rotate(-i * Math.PI / 180);
        }
        graphics.resetTransform();
    }
    create_window(){
        let octaneObject = new Octane();
        let windowProcesses = [
            spawn_process(octaneObject.update),
        ]
        let octaneWindow = spawn_window(windowProcesses, "Octane Game Engine");
        octaneWindow.width = 600;
        octaneWindow.height = 600;
        
        octaneWindow.init();
        octaneWindow.initProcesses();
        windows.push(octaneWindow);
    }
}class Gcode{
    constructor(){
        this.text_buffer = [];
        this.mode = "menu";
        this.line_index = 0;
        this.existing_lines = 0;
        this.live_reload = false;
        this.keys = get_devices().keyboard.keys;
        this.code_output = [];
        this.view_offset = 0;
        this.process;
    }
    update(canvas, graphics){
        setBackground(canvas, graphics);
        let devices = get_devices();

        if(this.text_buffer[this.line_index] === undefined)
            this.text_buffer[this.line_index] = "";

        for (let i = 0; i < devices.keyboard.keys.length; i++) {
          if(this.keys[i] !== devices.keyboard.keys[i]){
            this.keys[i] = devices.keyboard.keys[i];
            let key = this.keys[i];
            if (key !== "Enter" && key !== "Backspace" && key !== "ArrowUp" && key !== "ArrowDown" && key !== "ArrowLeft" && key !== "ArrowRight" && key !== "Alt" && key !== "Shift" && key !== "Tab" && key !== "Control") {
                this.text_buffer[this.line_index] += key;
            }
            if(key === "Backspace"){
                if(this.text_buffer[this.line_index].length > 0){
                    this.text_buffer[this.line_index] = this.text_buffer[this.line_index].slice(0, -1);
                } else if (this.line_index > 0) {
                    this.text_buffer.splice(this.line_index, 1);
                    this.line_index--;
                    this.existing_lines--;
                }
            }
            if(key === "Enter"){
                this.line_index++;
                this.existing_lines++;
                this.text_buffer.splice(this.line_index, 0, "");
            }
            if(key === "ArrowUp" && this.line_index > 0){
                this.line_index--;
            }
            if(key === "ArrowDown" && this.line_index < this.existing_lines){
                this.line_index++;
            }
          }
        }

        //Util bar
        graphics.fillRect(0, 0, canvas.width, 20);
        graphics.strokeStyle = colorScheme.elementColors;
        graphics.beginPath();
        graphics.moveTo(0, 20);
        graphics.lineTo(canvas.width, 20);
        graphics.stroke();

        labledButton(graphics, canvas.width - 44, 3, 40, 15, () => {
            let a = document.createElement("a");
            let text_buffer = [];
            for(let i = 0; i < this.text_buffer.length; i++){
                text_buffer[i] = this.text_buffer[i] + "\n";''
            }
            a.href = window.URL.createObjectURL(new Blob(text_buffer, {type: "text/plain"}));
            a.download = "javascript-code.js";
            a.click();
        }, "Save");
        labledButton(graphics, canvas.width - 88, 3, 40, 15, () => {
            let a = document.createElement("input");
            a.setAttribute('type','file');
            a.click();
            create_process(()=>{
                if(a.files[0] !== undefined){
                    let reader = new FileReader();
                    reader.readAsText(a.files[0], "UTF-8");
                    reader.onload = (evt) => {
                        let code = [];
                        let index = 0;
                        for(let i = 0; i < evt.target.result.length; i++){
                            let char = evt.target.result[i];
                            if(code[index] === undefined)
                                code[index] = ""
                            if(char === "\n"){
                                index++;
                            } else {
                                code[index] += char;
                            }
                        }
                        this.text_buffer = code;
                        this.existing_lines = index;
                    }
                    reader.onerror = (evt) => {
                        console.error("Failed to load file.")
                    }
                    exit();
                }
                sleep(200);
            })
        }, "Load");

        if(this.process === undefined){
            let convert_array = (array) => {
                let code = "";
                for(let i = 0; i < array.length; i++)
                    code += array[i] + "\n";
                return code;
            }
            let exec_code;
            if(this.live_reload !== true)
                exec_code = convert_array(this.text_buffer);
                labledButton(graphics, 4, 3, 40, 15, () => {
                    let gcode_proc = () => {
                        if(this.live_reload === true)
                            exec_code = convert_array(this.text_buffer);
                        let command = new Function(exec_code)();
                        if(command !== undefined)
                            this.code_output.push(command);
                    };
                    this.process = spawn_process(gcode_proc);
                    push_process(this.process);
                }, "Run");
                labledButton(graphics, 48, 3, 40, 15, () => {
                    try {
                        let command = new Function(exec_code)();
                        if(command !== undefined)
                            this.code_output.push(command);
                    } catch (e) {
                        this.code_output.push(e);
                    }
                }, "Exec");
        }

        if(this.process !== undefined){
            if(this.process.dead === true && this.process !== undefined){
                this.process = undefined;
            }else{
                if(this.process.suspended === false){
                    labledButton(graphics, 48, 3, 50, 15, () => {
                        if(this.process !== undefined){
                            suspend(this.process.PID);
                        }
                    }, "Pause");
                } else {
                    labledButton(graphics, 48, 3, 50, 15, () => {
                        if(this.process !== undefined){
                            resume(this.process.PID);
                        }
                    }, "Resume");
                }
            }
            labledButton(graphics, 4, 3, 40, 15, () => {
                if(this.process !== undefined){
                    kill(this.process.PID);
                    this.process = undefined;
                    this.code_output = [];
                }
            }, "Stop");
        }

        graphics.translate(0, 20);
        if((this.line_index - this.view_offset + 3) * 14 > canvas.width - 20){
            this.view_offset = Math.max(0, Math.round(((this.line_index + 3) * 14 - canvas.width)/14));
            console.log(this.view_offset)
        }
        
        graphics.fillStyle = colorScheme.dialogueBackground;
        graphics.fillRect(0, (this.line_index - this.view_offset) * 14 + 2, canvas.width, 15);

        graphics.fillStyle = colorScheme.textColor;
        for (let i = this.view_offset; i < this.text_buffer.length; i++){
            if((i - this.view_offset) * 14 + 14 > canvas.height){
                break;
            }
            graphics.fillText(this.text_buffer[i], 2, (i - this.view_offset) * 14 + 14);
        }


        graphics.translate(0, -20);

        if(this.process !== undefined){
            //Output window
            graphics.fillStyle = colorScheme.background;
            graphics.fillRect(0, canvas.height - 100, canvas.width, 100);
            graphics.strokeStyle = colorScheme.dialogueBackground;
            graphics.beginPath();
            graphics.moveTo(0, canvas.height - 100);
            graphics.lineTo(canvas.width, canvas.height - 100);
            graphics.stroke();
            graphics.fillStyle = colorScheme.dialogueBackground;
            graphics.fillRect(0, canvas.height - 114, canvas.width, 14);

            graphics.fillStyle = colorScheme.textColor;
            centerText(graphics, "Command Output", canvas.width/2, canvas.height - 107, 1, 1);

            let text_space = this.code_output.length * 12 + (canvas.height - 100) + 2;
            graphics.translate(0, canvas.height - text_space);
            for(let i = Math.max(0, Math.round(((this.code_output.length * 12)-100)/12)); i < this.code_output.length; i++){
                graphics.fillText(this.code_output[i], 2, i * 12 + (canvas.height - 100) + 12);
            }
            graphics.resetTransform();

        }
        sleep(40)
    }
    create_window(){
        var self = new Gcode();
        let gcode = (canvas, graphics) => {
            self.update(canvas, graphics);
        };
        quick_window(gcode, "GCode");
    }
    iconFunction(canvas, graphics){
        graphics.fillStyle = 'blue';
        graphics.fillRect(0, 0, canvas.width, canvas.height, 10);
        graphics.fillStyle = 'black';
        graphics.font = ((canvas.width + canvas.height) / 4) + "px Monospace";
        graphics.fillText("[G]", 5, canvas.height / 2);
    }
}{
    let find_freq = function(signal, frequency, pi_over_length){
        // Frequency is measured in hz per signal.length
        // If frequency = 1, the wave will begin at 1 and end at -1 on the graph

        //Xn = xn cos((2n + 1)pi * k / 2N)
        let freq_amp = 0;
        for(let i = 0; i < signal.length; i++){
            freq_amp += signal[i] * Math.cos(((2 * i + 1) * Math.PI * i) / (2 * signal.length));
            //frequency * i * pi_over_length
        }
        return freq_amp;
    }
    let coeff = -6.28318530718;
    function process_signal(signal){
        return signal.map((sng, i) => {
            let sum = 0;
            for(let i = 0; i < signal.length; i++)
                sum += signal[i] * (Math.pow(Math.E, (coeff * i)))
            return sum
        })
    }
    console.log(process_signal([2, 1, 0]));
}class ThreeD{
    constructor(){

    }
    update(){

    }
    create_window(){

    }
    iconFunction(){
        
    }
}const paint_window_size = 600;
class Paint{
    constructor(){
        this.canvases = [];
        this.draw_points = [];
        this.window;
        this.ui_area = 100;
        this.released = false;
        this.previous_mouse;
        this.draw_canvas = document.createElement("canvas");
        this.draw_canvas.width = paint_window_size - this.ui_area;
        this.draw_canvas.height = 400;
        this.draw_graphics = this.draw_canvas.getContext("2d");
        this.canvas_buffer = document.createElement("canvas");
        this.canvas_buffer.width = paint_window_size - this.ui_area;
        this.canvas_buffer.height = 400;
        this.graphics_buffer = this.canvas_buffer.getContext("2d");
        this.draw_color = "black"
    }
    run(canvas, graphics){
        setBackground(canvas, graphics);
        graphics.drawImage(this.draw_canvas, this.ui_area, 0);
        let devices = get_devices();
        if(devices.mouse.pressed === true && this.released === false){
            this.draw_graphics.strokeStyle = this.draw_color;
            this.previous_canvas = this.draw_canvas;
            this.previous_graphics = this.draw_graphics;
            this.previous_mouse_x = devices.mouse.x;
            this.previous_mouse_y = devices.mouse.y;
            this.draw_points.push([devices.mouse.x - this.ui_area, devices.mouse.y]);
        }
        if(devices.mouse.pressed === true){
            this.released = true;
            this.draw_graphics.beginPath();
            this.draw_graphics.moveTo(this.previous_mouse_x - this.ui_area, this.previous_mouse_y);
            this.draw_graphics.lineTo(devices.mouse.x - this.ui_area, devices.mouse.y)
            this.draw_points.push([devices.mouse.x - this.ui_area, devices.mouse.y]);
            this.draw_graphics.stroke();
            this.previous_mouse_x = devices.mouse.x;
            this.previous_mouse_y = devices.mouse.y;
            this.draw_graphics.closePath();
        }
        if(devices.mouse.pressed === false && this.released === true){
            this.graphics_buffer.beginPath();
            this.graphics_buffer.moveTo(this.draw_points[0][0], this.draw_points[0][1]);
            for(let i = 1; i < this.draw_points.length; i++)
                this.graphics_buffer.lineTo(this.draw_points[i][0], this.draw_points[i][1]);
            this.graphics_buffer.stroke();
            this.graphics_buffer.closePath();
            this.canvases.push(this.canvas_buffer);
            this.draw_graphics.clearRect(0, 0, this.draw_canvas.width, this.draw_canvas.height);
            this.draw_graphics.drawImage(this.canvas_buffer, 0, 0);
            this.draw_points = [];
            this.released = false;
        }
        sleep(20);
    }
    create_window(){
        let paint_instance = new Paint();
        let paint = function(canvas, graphics){
            paint_instance.run(canvas, graphics);
        }
        let window = spawn_window([spawn_process(paint)], "Paint");
        paint_instance.window = window;
        window.canvas.width = paint_window_size;
        window.canvas.height = 400;
        window.initialize();
        push_window(window);
    }
    iconFunction(canvas, graphics){
        graphics.fillStyle = "aqua"
        graphics.fillRect(0, 0, canvas.width, canvas.height);
    }
}class RayCast{
    constructor(){
        this.lights = [];
        this.objects = [];
        this.cycleCount = 0;
        this.execSpeed = 10;
        this.lightness = 1;
        this.lightQuality = 40; //The quality of the ray rendering
        this.radConst = (1 / 360) * (2 * Math.PI);
        this.init = false;

        let canvas_buffer = document.createElement("canvas");
        canvas_buffer.width = 450;
        canvas_buffer.height = 450;
        let graphics_buffer = canvas_buffer.getContext("2d");
        graphics_buffer.fillStyle = "black";
        graphics_buffer.fillRect(0, 0, canvas_buffer.width, canvas_buffer.height);
        this.image_data = graphics_buffer.getImageData(0, 0, canvas_buffer.width, canvas_buffer.height);
    }
    update(canvas, graphics){
        let self = this;
        let draw_point = function(x, y, r, g, b, a){
            let index = (Math.round(x) + Math.round(y) * canvas.width) * 4;
            self.image_data.data[index + 0] += r * a;
            self.image_data.data[index + 1] += g * a;
            self.image_data.data[index + 2] += b * a;
        }

        if(this.init === false){
            //Define functions
            let Light = function(x,y,color){
                this.x = x;
                this.y = y;
                this.color = color;
            }
            Light.prototype.update = function(degToRadConv){
                let rayDirectionX = Math.cos(degToRadConv);
                let rayDirectionY = Math.sin(degToRadConv);
                let tempLoopX = this.x;
                let tempLoopY = this.y;
                let luminosity = self.lightness / self.lightQuality;

                while(tempLoopX > 0 && tempLoopX < canvas.width && tempLoopY > 0 && tempLoopY < canvas.height && luminosity > 0){
                    draw_point(tempLoopX, tempLoopY, this.color[0], this.color[1], this.color[2], luminosity);
                    for(let i = 0; i < self.objects.length; i++){
                        let object = self.objects[i];
                        if(tempLoopX > object.x && tempLoopX < object.x + object.w && tempLoopY > object.y && tempLoopY < object.y + object.h){
                            switch(object.property){
                                case "reflective":
                                    if(Math.abs(tempLoopX - object.x) > Math.abs(tempLoopY - object.y))
                                        rayDirectionY = -rayDirectionY;
                                    else
                                        rayDirectionX = -rayDirectionX;
                                    break;
                                
                                    case "diffuse":
                                        const diffusion_coeff = 1/10;
                                        rayDirectionX += ((Math.random() * 2 - 1) * diffusion_coeff);
                                        rayDirectionY += ((Math.random() * 2 - 1) * diffusion_coeff);
                                        
                                        //Make sure value does not go outside bounds
                                        rayDirectionX = Math.max(-1, rayDirectionX);
                                        rayDirectionX = Math.min(1, rayDirectionX);
                                        rayDirectionY = Math.max(-1, rayDirectionY);
                                        rayDirectionY = Math.min(1, rayDirectionY);
                                        break;
                                    
                                    case "absorb":
                                        luminosity -= 1/(self.lightQuality*50);
                                        graphics.globalAlpha = luminosity;
                                        break;
                                        
                                    case "wall":
                                        luminosity = 0;
                                        graphics.globalAlpha = 0;
                                        break;
                            }
                        }
                    }
                    tempLoopX += rayDirectionX;
                    tempLoopY += rayDirectionY;
                }
            }
            let Object = function(x,y,w,h,property){
                this.x = x;
                this.y = y;
                this.w = w;
                this.h = h;
                this.property = property;
            }

            //Create lights and objects
            this.lights.push(new Light(100, 100, [255, 0, 0]));
            this.lights.push(new Light(150, 150, [0, 255, 0]));
            this.lights.push(new Light(200, 100, [0, 0, 255]));
            // this.lights.push(new Light(50, 50, [90, 90, 90]));
            // this.lights.push(new Light(400, 50, [150, 0, 255]));
            this.lights.push(new Light(200, 400, [255, 255, 255]));
            // this.lights.push(new Light(440, 440, [178, 178, 178]));
            // this.objects.push(new Object(50, 300, 100, 100, "absorb"));
            this.objects.push(new Object(350, 150, 50, 70, "reflective"));
            // this.objects.push(new Object(100, 110, 30, 70, "diffuse"));
            this.objects.push(new Object(350, 350, 50, 70, "wall"));
            this.objects.push(new Object(175, 175, 50, 50, "wall"));
            this.init = true;
        }

        for(let f = 0; f < self.execSpeed; f++){
            for(let l = 0; l < self.lightQuality; l++){
                self.cycleCount += 1/self.lightQuality;
                let degToRadConv = self.cycleCount * self.radConst;
                for(let i = 0; i < self.lights.length; i++)
                    self.lights[i].update(degToRadConv);
            }
        }
        if(this.cycleCount > 360)
            exit();

        graphics.putImageData(this.image_data, 0, 0);
        sleep(100);
    }
    create_window(){
        let RC = new RayCast();
        let raycast = function(canvas, graphics){
            RC.update(canvas, graphics);
        }
        quick_window(raycast, "Raycast");
    }
    iconFunction(canvas, graphics){
        graphics.fillStyle = "red";
        graphics.fillRect(0, 0, canvas.width, canvas.height);
    }
}class Physics{
    constructor(){
        this.objects = [];
        // this.gravity = 10;
        this.pixelColor = {
            r: 255,
            g: 255,
            b: 255,
            a: 255
        }
        this.init = false;
        this.ids = 0;
        this.scale = 8;
        this.width = 10;
        this.height = 10;

        this.objectMap = [];
        for(let i = 0; i < this.width; i++){
            this.objectMap[i] = [];
            for(let l = 0; l < this.height; l++){
                this.objectMap[i][l] = 0;
            }
        }

        this.canvas = document.createElement("canvas");
        this.canvas.width = this.width;
        this.canvas.height = this.height;
        this.canvas.visible = false;
        this.graphics = this.canvas.getContext("2d");
    }
    update(canvas, graphics){

        let self = this;

        //Actual physics
        function PhysicsObject(x, y){
            this.x = x;
            this.y = y;
            this.variation = Math.random();
            
            this.id = self.ids;
            self.ids++;
        }
        PhysicsObject.prototype.update = function(){
            let collided = false;
            let rightClosed = false;
            let leftClosed = false;
            
            // for(let i = 0; i < self.objects.length; i++){
            //     let _object = self.objects[i]
            //     if(this.id !== _object.id){
            //         if(Math.floor(this.x) === Math.floor(_object.x) && Math.floor(this.y) === Math.floor(_object.y)){
            //             this.y--;
            //             collided = true;
            //         }
            //         if(Math.floor(this.x) + 1 === Math.floor(_object.x) && Math.floor(this.y) === Math.floor(_object.y)){
            //             rightClosed = true;
            //         }
            //         if(Math.floor(this.x) - 1 === Math.floor(_object.x) && Math.floor(this.y) === Math.floor(_object.y)){
            //             leftClosed = true;
            //         }
            //     }
            // }

            if(collided){
                if(!rightClosed && !leftClosed){
                    this.x += Math.floor(Math.random() - 0.5) * 2 + 1;
                } else {
                    if(!rightClosed && this.x !== self.canvas.width - 1){
                        this.x++;
                    }
                    if(!leftClosed && this.x !== 1){
                        this.x--;
                    }    
                }
            }

            if(this.x < 0)
                this.x = 0;
            if(this.y < 0){
                this.y = 0;
                collided = false;
            }
            if(this.x > self.width)
                this.x = self.width;
            if(this.y > self.height - 1){
                this.y = self.height - 1;
                collided = true;
            }
            
            if(!collided){
                this.y ++;
            }else{
                // this.y--;
            }
        }
        PhysicsObject.prototype.draw = function(){
            if(this.x  > 0 && this.x < self.canvas.width && this.y > 0 && this.y < self.canvas.width){
                self.graphics.fillStyle = "blue";
                self.graphics.fillRect(this.x, this.y, 1, 1);
            }
        }
        let devices = get_devices();
        if(devices.mouse.clicked){
            this.objects.push(new PhysicsObject(Math.floor(Math.random() * this.width), Math.floor(Math.random() * this.height)));
        }

        //Update physics
        for(let i = 0; i < this.objects.length; i++){
            create_thread(() => {this.objects[i].update();});
        }

        //Drawing code
        create_thread(() => {
            this.graphics.fillStyle = "black";
            this.graphics.fillRect(0, 0, this.canvas.width, this.canvas.height);
        });
        for(let i = 0; i < this.objects.length; i++){
            create_thread(() => {this.objects[i].draw();});
        }
        create_thread(() => {
            graphics.drawImage(this.canvas, 0, 0, canvas.width, canvas.height);
        });
    }
    create_window(){
        let physics = new Physics();
        let updateEngine = (canvas, graphics) => {
            physics.update(canvas, graphics);
        }

        quick_window(updateEngine, "Physics");

    }
    iconFunction(){

    }
}class SystemMonitor{
    constructor(){
        this.percent_data = [];
        this.offset = 0;
        this.menu = "processes";
        this.element_spacing = 16;
        this.text_size = 12;
        this.spacing = 40;
        this.usage_size = 16;
    }
    update(){
        this.percent_data.push(get_performance().percent);
    }
    renderGraphics(canvas, graphics){
        setBackground(canvas, graphics);

        if(this.menu === "processes"){
            let sys_info = get_system_info();
            let usage = sys_info.usage;
            graphics.font = this.usage_size + "px Monospace";
            graphics.fillStyle = colorScheme.textColor;
            graphics.fillText(Math.round(usage.total) + "%", 10, this.spacing - this.usage_size);
            graphics.fillStyle = "blue";
            graphics.fillText(Math.round(usage.user) + "%", 10 + (this.spacing * 1), this.spacing - this.usage_size);
            graphics.fillStyle = "red";
            graphics.fillText(Math.round(usage.system) + "%", 10 + (this.spacing * 2), this.spacing - this.usage_size);

            let processes = sys_info.processes;
            processes = processes.sort((a, b) => b.cpu_time - a.cpu_time)
            graphics.translate(0, this.spacing);
            graphics.font = this.text_size + "px Monospace";
            graphics.fillStyle = colorScheme.dialogueBackground;
            graphics.fillRect(0, 0, canvas.width, 1)
            for(let i = 0; i < processes.length; i++){
                let process = processes[i];
                graphics.fillStyle = colorScheme.background;
                graphics.fillRect(0, i * this.element_spacing + 1, canvas.width, this.element_spacing);
                graphics.fillStyle = colorScheme.dialogueBackground;
                graphics.fillRect(0, (i + 1) * this.element_spacing, canvas.width, 1)
                graphics.fillStyle = colorScheme.textColor;
                //Name
                graphics.fillText(process.process_name, 5, (i + 1) * this.element_spacing - (this.element_spacing - this.text_size) / 2, 160);
                //CPU percent
                graphics.fillText(Math.round(process.cpu_time / (raw_uptime().active - process.starting_uptime) * 100) + "%", 162, (i + 1) * this.element_spacing - (this.element_spacing - this.text_size) / 2, 20);
                //CPU time
                graphics.fillText((Math.round(process.cpu_time / 10) / 100) + "s", 187, (i + 1) * this.element_spacing - (this.element_spacing - this.text_size) / 2, 40);
                //CPU time
                graphics.fillText(process.PID, 230, (i + 1) * this.element_spacing - (this.element_spacing - this.text_size) / 2, 40);
            }
            graphics.translate(0, -this.spacing);
        }
        if(this.menu === "graph"){
            graphics.strokeStyle = "blue";
            graphics.lineWidth = 2;
            graphics.beginPath();
            this.offset = Math.max(0, this.percent_data.length - canvas.width);
            for(let i = this.offset; i < this.percent_data.length; i++)
                graphics.lineTo(i - this.offset, (1 - this.percent_data[i] / 100) * canvas.height);
            graphics.stroke();
        }
    }
    iconFunction(canvas, graphics){
        graphics.fillStyle = "white";
        graphics.fillRect(0, 0, canvas.width, canvas.height);
        graphics.strokeStyle = "black";

        graphics.beginPath();
        graphics.lineTo(10, canvas.height / 1.5);
        graphics.lineTo(canvas.width / 2, canvas.height / 3);
        graphics.lineTo(canvas.width / 1.5, canvas.height / 2);
        graphics.lineTo(canvas.width - 10, canvas.height / 4);
        graphics.stroke();
    }
    create_window(){
        let app = new SystemMonitor();
        let init = false;
        let sysmon = (canvas, graphics) => {
            app.renderGraphics(canvas, graphics);;
            sleep(3000);
        }
        let process = spawn_process(sysmon);
        process.thread(() => {
            app.update();
            sleep(300);
        });
        create_window([process], "System Monitor");
    }
}class CookieClicker{
    constructor(){
        this.money = 0;
        this.shops = [];
        this.clickPower = 1;
        this.cps = 0;
        this.spacebarPressed = false;
        this.timer = create_timer();

        let self = this;
        function Shop (price, cps, title, customFunction) {
            this.price = price;
            this.cps = cps;
            this.title = title;
            this.custom = (customFunction !== undefined);
            this.customFunction = customFunction;
        }
        function createShop (cps, title) {
            self.shops.push(new Shop(Math.pow(cps, 0.9) * 100, cps, title));
        }
        //Create shops
        let powerClickShop = new Shop(10, 0, "Power Click", () => {});
        powerClickShop.customFunction = () => {
            powerClickShop.price = powerClickShop.price * 20;
            this.clickPower *= 2;
        }
        self.shops.push(powerClickShop);
        createShop(0.1, "Slave");
        createShop(1, "Granny");
        createShop(5, "Farmer");
        createShop(20, "Plantation");
        createShop(100, "Factory");
        createShop(500, "Shipment");
        createShop(1000, "Rocket");
        createShop(10000, "Wormhole");
        createShop(50000, "Multiverse");
        createShop(100000, "Dimension");
    }
    update(canvas, graphics){
        //Background
        setBackground(canvas, graphics);

        //Draw shops
        for(var i = 0; i < this.shops.length; i++){
            let currentButton = this.shops[i];
            labledButton(graphics, 5, 5 + i*35, canvas.width/2, 30, () => {
                if(this.money >= currentButton.price){
                    this.money -= currentButton.price;
                    if(currentButton.custom !== true){
                        this.cps += currentButton.cps;
                        currentButton.price = currentButton.price * 1.2;
                    }else{
                        currentButton.customFunction();
                    }
                }
            }, currentButton.title + "- " + currentButton.cps + " CPS, $" + Math.round(currentButton.price));
        }

        //Draw cookie
        graphics.fillStyle = "#005096";
        graphics.ellipse(canvas.width/4 + canvas.width/2, canvas.height/2, canvas.height/3, canvas.height/3, 0, 0, 0, false);
        let devices = get_devices();
        if(devices.mouse.pressed && this.keyPressed === false){
            this.money += this.clickPower;
            this.keyPressed = true;
        }
        if(!devices.mouse.pressed){
            this.keyPressed = false;
        }
        blankButton(canvas.width/4 + canvas.width/2 - canvas.height/6, canvas.height/2 - canvas.height/6, canvas.height/3, canvas.height/3, () => {this.money += this.clickPower});

        //Draw money
        graphics.fillStyle = colorScheme.textColor;
        centerText(graphics, "$" + Math.floor(this.money), canvas.width/4 + canvas.width/2, 30, 0, 0, 30);
        centerText(graphics, "CPS: " + (Math.floor(this.cps*10)/10), canvas.width/4 + canvas.width/2, canvas.height - 30, 0, 0, 20);

        this.timer.update();
        this.money += getTransition(this.cps, 1000, this.timer);
        sleep(50);
    }
    create_window(){
        var self = new CookieClicker();
        quick_window((canvas, graphics) => {self.update(canvas, graphics)}, "Cookie Clicker");
    }
    iconFunction(canvas, graphics){
        graphics.fillStyle = "#964b00";
        graphics.fillRect(0, 0, canvas.width, canvas.height, 10);
        graphics.fillStyle = "#965a0a";
        graphics.ellipse(100, 100, 50, 75, Math.PI / 4, 0, 2 * Math.PI);
        graphics.ellipse(canvas.width/2, canvas.height/2, Math.max(canvas.width - 15, 0), Math.max(canvas.height - 15, 0), 0, 2 * Math.PI, 0);
    }
}class Autoclick{
    constructor(){
        this.clicked = false;
        this.clicking = false;
    }
    update(canvas, graphics){
        setBackground(canvas, graphics);
        this.clicking = booleanToggleButton(graphics, this.clicking, "Start autoclicker", "Stop autoclicker", 20, 20, canvas.width-40, canvas.height-40, () => {
            create_timeout(() => {
                if(this.clicking){
                    this.startClicking = true;
                }else{
                    this.startClicking = false;
                }
            }, 1000);
        });
        
        if(this.clicking && this.startClicking){
            let devices = get_devices();
            if(this.clicked === false){
                devices.mouse.clicked = true;
                this.clicked = true;
                return;
            }
            if(this.clicked === true){
                devices.mouse.clicked = false;
                this.clicked = false;
                return;
            }
        }
    }
    create_window(){
        let autoclick = new Autoclick();
        quick_window((canvas, graphics) =>{autoclick.update(canvas, graphics)}, "Autoclicker");
    }
    iconFunction(canvas, graphics) {
        graphics.fillStyle = "#8888FF"
        graphics.fillRect(0,0,canvas.width, canvas.height);

        graphics.translate(35, 30);
        graphics.scale(3,3);
        //The mouse
        graphics.strokeStyle = 'white';
        graphics.fillStyle = 'black';
        graphics.lineWidth = 1;
        graphics.beginPath();
        //Base (left)
        graphics.moveTo(0, 0);
        graphics.lineTo(0, 13);
        //Handle (left)
        graphics.lineTo(3, 10);
        //Handle base (l/r)
        graphics.lineTo(5, 15);
        graphics.lineTo(8, 14);
        //Handle (right)
        graphics.lineTo(6, 9);
        //Base (right)
        graphics.lineTo(10, 9);
        graphics.lineTo(0, 0);
    
        graphics.fill();
        graphics.stroke();
    }
}class TTY {
  constructor() {

    this.prompt = "[jsterm]$ ";
    this.textArray = [];
    this.promptArray = [];
    this.textLine = 0;
    this.textBuffer = [];
    this.keys = get_devices().keyboard.keys;
    this.keyPressed = false;
    this.textOrder = 0;
    this.root = false;
    this.kernel_key = null;
  }
  update() {
    //Commandline functions
    var self = this;
    function clr() {
      self.textArray = [];
    }
    function printout(obj) {
      if (obj[0]) {
        for (var i in obj) {
          self.textArray.push(obj[i]);
        }
      } else {
        self.textArray.push(obj);
      }
    }
    function su() {
      self.kernel_key = get_kernel_key();
      self.root = true;
      self.prompt = "[kernel]# ";
    }
    let devices = get_devices();
    if (devices.keyboard.keyCodes[13] && !this.keyPressed) {
      this.textArray.push(this.textBuffer);
      this.promptArray[this.textArray.length - 1] = this.prompt;
      let parse_text = string => {
        let string_buffer = "";
        let delimiter = "\n";
        if(string[0] === "{" || string[0] === "[")
          delimiter = ",";
        for (let i = 0; i < string.length; i++) {
          let character = string[i];
          if (character !== delimiter) {
            string_buffer += character;
          }
          if(character === delimiter || i === string.length - 1){
            this.textArray.push(string_buffer)
            string_buffer = "";
          }
        }
      }
      if (this.textBuffer) {
        let stringToCommand, stringToCommandToString;
        try {
          if (this.root !== true){
            stringToCommand = eval(this.textBuffer);
          } else {
            if (this.textBuffer === "clr()")
              self.textArray = [];
            else
              stringToCommand = run_as_root(this.textBuffer, this.kernel_key);
          }
          if (stringToCommand !== undefined){
            if(typeof stringToCommand === "object")
             stringToCommandToString = JSON.stringify(stringToCommand);
            else
              stringToCommandToString = stringToCommand.toString();
            parse_text(stringToCommandToString);
          }
        } catch (e) {
          this.textArray.push(e);
          parse_text(e);
          stringToCommandToString = e;
        }
      }
      this.textBuffer = "";
      this.keyPressed = true;
      return;
    } else {
      if (devices.keyboard.keyCodes[8] && !this.keyPressed) {
        if (this.textBuffer.length > 0) {
          this.textBuffer = this.textBuffer.slice(0, -1);
        }
        this.keyPressed = true;
      }
      if (devices.keyboard.keyCodes[38] && !this.keyPressed && this.textArray[this.textArray.length - (this.textOrder + 1)] !== undefined) {
        this.textOrder++;
        this.textBuffer = this.textArray[this.textArray.length - this.textOrder];
        this.keyPressed = true;
      }
      if (devices.keyboard.keyCodes[40] && !this.keyPressed && this.textArray[this.textArray.length - (this.textOrder - 1)] !== undefined) {
        this.textOrder--;
        this.textBuffer = this.textArray[this.textArray.length - this.textOrder];
        if (this.textBuffer === undefined) {
          this.textOrder = 0;
        }
        this.keyPressed = true;
      }
      if (devices.keyboard.info.keyCode !== 40 && !this.keyPressed) {
        if (devices.keyboard.info.keyCode !== 38) {
          this.textOrder = 0;
        }
      }
      if (!devices.keyboard.info.keyIsPressed) {
        this.keyPressed = false;
      }
      for (let i in devices.keyboard.keys) {
        if (this.keys[i] !== devices.keyboard.keys[i]) {
          this.keys[i] = devices.keyboard.keys[i];
          let key = this.keys[i];
          if (key !== "Enter" && key !== "Backspace" && key !== "ArrowUp" && key !== "ArrowDown" && key !== "Alt" && key !== "Shift" && key !== "Tab" && key !== "Control") {
            this.textBuffer += key;
          }
        }
      }
    }
    sleep(40);
  }
  draw(canvas, graphics) {
    graphics.font = '12px Monospace';
    try {
      if (stress) {
        graphics.fillStyle = 'black';
        graphics.fillRect(0, 0, canvas.width, canvas.height);
        graphics.fillStyle = 'white';
      }
    } catch (e) {
      setBackground(canvas, graphics);
      graphics.fillStyle = colorScheme.textColor;
    }
    for (var i = 0; i < this.textArray.length; i++) {
      let currentPrompt = this.promptArray[i];
      if (currentPrompt === undefined)
        currentPrompt = "";
      graphics.fillText(currentPrompt + this.textArray[i], 2, i * 12 + 12);
    }
    graphics.fillText(this.prompt + this.textBuffer, 2, this.textArray.length * 12 + 12);
    sleep(40);
  }
  create_window() {
    var tty = new TTY();

    let terminal = function(canvas, graphics){
      tty.draw(canvas, graphics);
      tty.update();
    }
    create_window([
      spawn_process(terminal)
    ], "Terminal");
  }
  iconFunction(canvas, graphics) {
    graphics.fillStyle = 'black';
    graphics.fillRect(0, 0, canvas.width, canvas.height, 10);
    graphics.fillStyle = 'white';
    graphics.font = ((canvas.width + canvas.height) / 4) + "px Monospace";
    graphics.fillText(">_", 5, canvas.height / 2);
  }
}
try {
  if (stress) {
    console.log("Starting TTY standalone");
    var tty = new TTY();
    let terminal = function(){
      tty.draw(canvas, graphics);
      tty.update();
    }
    create_init(terminal);
  }
} catch (error) { }/* Graphite Virtual Machine
    RISC archetecture [based on the Evergreen Architecture]
    One byte = 8 bits
    Configurable architecture size, RAM size, and CPU count

    Bit Architecture: undecided
    Clock speed: Depends on your computer

Set specs as needed.
*/

{

    let convert_to_binary = function (number) {
        return (number).toString(2);
    }
    let convert_to_decimal = function (binary) {
        return parseInt(binary, 2);
    }
    let convert_from_hex = function (hex) {
        return parseInt(hex, 16);
    }
    let append_value = function (target, binary) {
        for (let i = 0; i < binary.length; i++) {
            target.push(binary[i]);
        }
    }
    let insdc = function(verb, binary){
        return {
            verb: verb,
            binary: binary
        }
    }
    let instruction_description_table = [
        insdc("lod", 0),
        insdc("str", 1),
        insdc("set", 2),
        insdc("add", 3),
        insdc("jdmp", 4),
        insdc("sub", 5),
        insdc("and", 6),
        insdc("brc", 7),
        insdc("hlt", 8),
        insdc("rld", 9),
        insdc("cbr", 10),
    ]
    let VMIDs = 0;

    class CarboniteVM {
        constructor(ram_size, arch, CPUs) {
            //VM ID configuration
            this.id = VMIDs;
            //Size configurations
            this.arch = arch;
            this.cpus = CPUs;

            this.instruction_length = 4 + this.arch;
            this.increment = Math.floor(this.instruction_length / 8) + 1;

            //Vectors
            this.reset_vector = 64;

            //Initialize data sets
            this.ram = new Uint8Array(ram_size);
            this.reg = 0;
            this.cache = [];
            this.program_counter = 0;
            this.halt = false;
            this.output = [];

            /* Instruction set:
                0: LOD (reg = m) [0000]
                1: STR (m = reg) [0001]
                2: SET (reg = arg) [0010]
                3: ADD (reg += op) [0011]
                4: DMP (dump register contents through console.log) [0100]
                5: SUB (reg = XOR(reg, m) ) [0101]
                6: AND (reg = AND(reg, m)) [0110]
                7: BRC (pc = m) [0111]
                8: HLT (stop the CPU from executing) [1000]
                9: RLD (m[m[arg]] = reg) [1001] (set the register to be the memory address referenced at the ram address specified)
                10: CBR (if->reg=0: pc = m) [1010]

            */
            this.instruction_set = [
                (arg) => {//LOD
                    this.reg = this.ram[arg];
                },
                (arg) => {//STR
                    this.ram[arg] = this.reg;
                },
                (arg) => {//SET
                    this.reg = arg;
                },
                (arg) => {//ADD
                    this.reg += arg;
                },
                () => {//DMP
                    console.log(this.reg);
                },
                (arg) => {//SUB
                    this.reg -= arg;
                },
                (arg) => {//AND
                    this.reg = (arg === this.reg);
                },
                (arg) => {//BRC
                    this.program_counter = arg * this.increment;
                    return 0;
                },
                () => {//HLT
                    this.halt = true;
                    return 0;
                },
                (arg) => {//RLD
                    this.ram[this.ram[arg]] = this.reg;
                },
                (arg) => {//CBR
                    if(this.reg === 0){
                        this.program_counter = arg * this.increment;
                        return 0;
                    }
                },

            ];

            VMIDs++;
        }
        init() {
            console.log("VM " + this.id + " initialized");
        }
        print_debug() {
            console.log({
                cpus: this.cpus,
                ram: this.ram,
                reg: this.regs,
                id: this.id,
            });
        }
        instruct(op_code, arg_code) {
            /* 4 bit op code, 8-128 bit arg code */

            this.instruction_set[op_code](arg_code);
        }
        clock() {
            if (this.halt === false) {
                this.opcode_buffer = 0;
                for(let i = 1; i < this.increment; i++)
                    this.opcode_buffer += this.ram[this.program_counter + i];
                try{
                    let instruction_output = this.instruction_set[this.ram[this.program_counter]](this.opcode_buffer);

                    if(instruction_output !== 0){
                        this.program_counter += this.increment;
                    }
                    if (this.program_counter >= this.ram.length) {
                        this.halt = true;
                    }
                } catch (e) {
                    console.error("Virtual machine " + this.id + " has encountered a fatal error.");
                    console.error(e);
                    this.halt = true;
                }
            }
        }
        instruct_hex(op_code, arg_code) {
            this.instruction_set[convert_from_hex(op_code)](convert_from_hex(arg_code));
        }
        set_program(program) {
            /* Program Layout:
            - arch: x
            - data: [[op, arg],[op, arg],[op, arg],[op, arg]]
            MUST NOT USE HEX.
            */
            if (program.arch === this.arch) {
                for (let i = 0; i < program.data.length; i++) {
                    this.ram[i * this.increment] = program.data[i][0];
                    for(let l = 0; l < Math.floor(program.data[i][1]/255) + 1; l++){
                        this.ram[(i * this.increment) + l + 1] = Math.min(255, program.data[i][1] - (255 * l));
                    }
                }
            }
        }
        reset() {
            this.ram = new Uint8Array(this.ram.length);
            this.reg = 0;
            this.cache = [];
            this.program_counter = 0;
            this.halt = false;
        }
    }
    function createVM(ram_size, arch, CPUs) {
        return new CarboniteVM(ram_size, arch, CPUs);
    }
    function runVM(virtual_machine, max_time) {
        let _max_time = 10;
        if (max_time) {
            _max_time = max_time;
        }
        let start_time = Date.now() + _max_time;
        while (Date.now() < start_time) {
            virtual_machine.clock();
        }
    }
    function convert_program_to_decimal(program) {

    }
}

class VMGUI{
    constructor(){
        this.vm = createVM(256, 8, 1);
    }
    update(){

    }
}{
    let windows = [];
    const button_padding = 8;
    let monitor_refresh_rate = 60;
    const animation_time = 450;
    let animation = 0;
    let alpha_value = 1;
    let window_exec = null;
    let window_tint = [0, 0, 0, 0];
    let foreground_image;
    {
        //Detect monitor frame rate:
        let test_count = 200;
        let run_count = 0;
        let timer = performance.now();
        let runs = [];
        let tester = function () {
            let time_buffer = performance.now();
            runs.push(1000 / Math.max(time_buffer - timer, 0));
            timer = time_buffer;
            if (run_count < test_count)
                requestAnimationFrame(tester);
            else {
                for (let i = 0; i < run_count; i++)
                    monitor_refresh_rate += runs[i];
                monitor_refresh_rate = monitor_refresh_rate / run_count;
                console.log("Detected refresh rate: " + monitor_refresh_rate + " FPS");
            }
            run_count++;
        }
        requestAnimationFrame(tester);
    }
    let wm_window = function (processes, window_name) {
        this.canvas = document.createElement("canvas");
        this.canvas.width = 450;
        this.canvas.height = 450;
        this.graphics = this.canvas.getContext("2d");

        this.x = canvas.width / 2 - this.canvas.width / 2;
        this.y = canvas.height / 2 - this.canvas.height / 2;
        this.window_name = "window";
        if (window_name !== undefined)
            this.window_name = window_name;


        this.processes = [];
        this.processes_buffer = processes;
        this.direct_render = false;
        this.foreground = false;

        this.title_bar_height = 40;
        this.dragged = false;
        this.has_focus = false;
        this.request_focus = false;
        this.focusable = true;

        this.fade = 0;
        this.timer = create_timer();
    }
    wm_window.prototype.kill = function () {
        //Kill all processes linked to the window
        for (let i = 0; i < this.processes.length; i++)
            kill(this.processes[i].PID);
    }
    wm_window.prototype.close = function () {
        this.dying = true;
    }
    wm_window.prototype.initialize = function () {
        for (let i = 0; i < this.processes_buffer.length; i++) {
            let process_buffer = this.processes_buffer[i];
            for(let l = 0; l < process_buffer.threads.length; l++){
                let command = process_buffer.threads[l].command;
                process_buffer.threads[l].command = () => {
                    let devices = get_devices();
                    let old_get_devices = get_devices;
                    let old_canvas = canvas;
                    let old_graphics = graphics;
                    let old_dimensions = {};
                    if (this.direct_render !== true) {
                        canvas = this.canvas;
                        graphics = this.graphics;
                    }
                    if (this.direct_render !== true) {
                        devices.mouse.x -= this.x;
                        devices.mouse.y -= this.y;
                    }
                    let old_keyboard = {
                        keys: devices.keyboard.keys,
                        keyCodes: devices.keyboard.keyCodes,
                        info: devices.keyboard.info,
                        keyCode: devices.keyboard.keyCode,
                        info: devices.keyboard.info
                    };
                    if (this.has_focus === false) {
                        devices.keyboard.keys = [];
                        devices.keyboard.keyCodes = [];
                        devices.keyboard.keyCode = 0;
                        devices.keyboard.pressed = false;
                        devices.keyboard.info = {};
                    }
                    get_devices = function () {
                        return devices;
                    }
    
                    window_exec = this;
                    command(canvas, graphics);
                    window_exec = null;
    
                    canvas = old_canvas;
                    graphics = old_graphics;
                    get_devices = old_get_devices;
                    if (this.direct_render !== true) {
                        devices.mouse.x += this.x;
                        devices.mouse.y += this.y;
                    }
                    devices.keyboard = old_keyboard;
                };
            }
            this.processes.push(process_buffer);
            push_process(process_buffer);
        }
    }
    wm_window.prototype.draw_top_bar = function (graphics, positionX, positionY, fade) {
        if (this.title_bar_height > 0) {
            graphics.translate(positionX, positionY);

            let scaled_title_bar_height = Math.max(this.title_bar_height * fade, 1);
            let scaled_width = Math.max(this.canvas.width * fade, 1);

            //Actual top bar
            // graphics.fillStyle = "#222222";
            if (darkmode === true) {
                if (this.has_focus !== true)
                    graphics.fillStyle = colorScheme.elementColors;
                else
                    graphics.fillStyle = colorScheme.background;
            } else {
                if (this.has_focus !== true)
                    graphics.fillStyle = colorScheme.background;
                else
                    graphics.fillStyle = colorScheme.elementColors;
            }

            graphics.strokeStyle = colorScheme.elementColors;
            graphics.lineWidth = 1;
            graphics.fillRect(0, -scaled_title_bar_height, scaled_width, scaled_title_bar_height);
            graphics.beginPath();
            graphics.moveTo(0, 0);
            graphics.lineTo(scaled_width, 0);
            graphics.stroke();

            // graphics.fillStyle = "white";
            graphics.fillStyle = colorScheme.textColor;
            graphics.font = "12px Monospace";
            // graphics.fillText(this.windowName, scaled_width/2, this.canvas.height/2);
            if (fade > 0.5)
                graphics.fillText(this.window_name, scaled_width / 2 - (graphics.measureText(this.window_name).width / 2), (12 / 3) - scaled_title_bar_height / 2);
            //Close button
            graphics.fillStyle = "red";
            graphics.fillRect(scaled_width - button_padding - (scaled_title_bar_height - button_padding * 2),
                button_padding - (scaled_title_bar_height - 1),
                Math.max(scaled_title_bar_height - button_padding * 2, 0),
                Math.max(scaled_title_bar_height - button_padding * 2, 0));
            graphics.translate(-positionX, -positionY);
        }
    }
    wm_window.prototype.draw = function (graphics, foreground_graphics) {
        //Animations
        this.timer.update();
        if (this.dying !== true) {
            if (Math.round(this.fade * 100) / 100 < 1)
                this.fade += (getTransition(1, animation_time, this.timer) - (getTransition(this.fade, animation_time, this.timer))) * 2;
            else
                this.fade = 1;
        } else {
            if (Math.floor(this.fade * 100) / 100 > 0)
                this.fade -= (getTransition(1, animation_time, this.timer) - (getTransition(1 - this.fade, animation_time, this.timer))) * 2;
            else {
                this.fade = 0;
                this.dead = true;
            }
        }
        let draw_surface = graphics;
        if (this.foreground === true)
            draw_surface = foreground_graphics;
        if (this.fade < 1) {
            switch (animation) {
                case 0:
                    draw_surface.globalAlpha = this.fade * alpha_value;
                    draw_surface.translate((this.x + this.canvas.width / 2) - (this.canvas.width / 2 * this.fade), (this.y + this.canvas.height / 2) - (this.canvas.height / 2 * this.fade));
                    draw_surface.scale(this.fade, this.fade);
                    draw_surface.drawImage(this.canvas, 0, 0);
                    this.draw_top_bar(draw_surface, 0, 0, 1);
                    draw_surface.resetTransform();
                    draw_surface.globalAlpha = 1;
                    draw_surface.scale(1, 1);
                    break;
                case 1:
                    let adjusted_fade = Math.max(this.fade, 1 / this.canvas.width);

                    let scaled_x = (this.x + this.canvas.width / 2) - (this.canvas.width / 2 * adjusted_fade);
                    let scaled_y = (this.y + this.canvas.height / 2) - (this.canvas.height / 2 * adjusted_fade);
                    let sample_x = (this.canvas.width / 2) - (this.canvas.width / 2 * adjusted_fade);
                    let sample_y = (this.canvas.height / 2) - (this.canvas.height / 2 * adjusted_fade);
                    // draw_surface.translate((this.x + this.canvas.width / 2) - (this.canvas.width / 2 * adjusted_fade), (this.y + this.canvas.height / 2) - (this.canvas.height / 2 * adjusted_fade));
                    // draw_surface.scale(adjusted_fade, adjusted_fade);
                    let image = this.graphics.getImageData(sample_x, sample_y, this.canvas.width * adjusted_fade + 1, this.canvas.height * adjusted_fade + 1);
                    draw_surface.putImageData(image, scaled_x, scaled_y);
                    this.draw_top_bar(draw_surface, scaled_x, scaled_y, this.fade);
                    break;

            }
        } else {
            // let image = this.graphics.getImageData(0, 0, this.canvas.width, this.canvas.height);
            // draw_surface.putImageData(image, this.x, this.y);
            draw_surface.drawImage(this.canvas, Math.round(this.x), Math.round(this.y));
            this.draw_top_bar(draw_surface, this.x, this.y, 1);
        }
    }
    wm_window.prototype.update_logic = function () {
        let devices = get_devices();
        if (devices.mouse.x > this.x && devices.mouse.x < this.x + this.canvas.width && devices.mouse.y > this.y - this.title_bar_height && devices.mouse.y < this.y + this.canvas.height && this.focusable && devices.mouse.pressed && !this.request_focus && this.dying !== true)
            this.request_focus = true;
        if (this.has_focus === true) {
            if (devices.mouse.x > this.x + this.canvas.width - button_padding - (this.title_bar_height - button_padding * 2) &&
                devices.mouse.y > this.y + button_padding - (this.title_bar_height - 1) &&
                devices.mouse.x < this.x + this.canvas.width - button_padding &&
                devices.mouse.y < this.y + (button_padding - (this.title_bar_height - 1)) + (this.title_bar_height - button_padding * 2) && devices.mouse.pressed && this.dragged === false) {
                this.close();
                return;
            }
            //Movement
            if (devices.mouse.x > this.x && devices.mouse.x < this.x + this.canvas.width && devices.mouse.y > this.y - this.title_bar_height && devices.mouse.y < this.y && devices.mouse.pressed && this.dragged === false && this.has_focus) {
                this.intital_drag = {
                    mouseX: devices.mouse.x,
                    mouseY: devices.mouse.y,
                    windowX: this.x,
                    windowY: this.y
                }
                this.dragged = true;
            }
            if (this.dragged === true) {
                if (!devices.mouse.pressed)
                    this.dragged = false;
                this.x = (devices.mouse.x - this.intital_drag.mouseX) + this.intital_drag.windowX;
                this.y = (devices.mouse.y - this.intital_drag.mouseY) + this.intital_drag.windowY;
            }
        }
    }

    function spawn_window(processes, window_name) {
        return new wm_window(processes, window_name);
    }
    function create_window(processes, window_name) {
        let window = new wm_window(processes, window_name);
        window.initialize();
        windows.push(window);
    }
    function quick_window(handler, window_name) {
        create_window([spawn_process(handler)], window_name);
    }
    function push_window(window) {
        windows.push(window);
    }
    function set_alpha(alpha) {
        alpha_value = alpha;
    }
    function set_tint(r, g, b, a) {
        window_tint[0] = r;
        window_tint[1] = g;
        window_tint[2] = b;
        window_tint[3] = a;
    }
    function render_mode(mode) {
        switch (mode) {
            case "direct":
                window_exec.direct_render = true;
                break;
            case "normal":
                window_exec.direct_render = false;
                break;
        }
    }

    //Background
    let background_image;
    let bg_canvas = document.createElement("canvas");
    bg_canvas.width = canvas.width;
    bg_canvas.height = canvas.height;
    let bg_graphics = bg_canvas.getContext('2d');
    function set_background(handler) {
        handler(bg_canvas, bg_graphics);
        background_image = bg_graphics.getImageData(0, 0, canvas.width, canvas.height);
    }
    function get_background_image() {
        return background_image;
    }
    // Default background
    set_background((canvas, graphics) => {
        graphics.fillStyle = "gray";
        graphics.fillRect(0, 0, canvas.width, canvas.height);
    })

    //Cursor
    let cursor_handler;
    function set_cursor(handler) {
        cursor_handler = handler;
    }
    set_cursor(graphics => {//Default wm cursor
        graphics.strokeStyle = 'black';
        graphics.fillStyle = 'white';
        graphics.lineWidth = 1;
        graphics.beginPath();
        //Base (left)
        graphics.moveTo(0, 0);
        graphics.lineTo(0, 13);
        //Handle (left)
        graphics.lineTo(3, 10);
        //Handle base (l/r)
        graphics.lineTo(5, 15);
        graphics.lineTo(8, 14);
        //Handle (right)
        graphics.lineTo(6, 9);
        //Base (right)
        graphics.lineTo(10, 9);
        graphics.lineTo(0, 0);

        graphics.fill();
        graphics.stroke();
    });

    //Foreground
    let foreground_graphics;
    {
        let fg_canvas = document.createElement("canvas");
        fg_canvas.width = canvas.width;
        fg_canvas.height = canvas.height;
        foreground_graphics = fg_canvas.getContext("2d");
    }

    //Init
    document.body.style.cursor = 'none';
    let time_marker = performance.now();
    let wm_round_trip = 0;
    graphics.imageSmoothingEnabled = false

    let performance_display = () => {
        graphics.font = '14px Monospace';
        graphics.fillStyle = '#AAAAEE';
        graphics.fillRect(76, 0, 38, 30);
        graphics.fillStyle = 'black';
        graphics.fillText(Math.round(1000 / wm_round_trip), 86, 19);
    };


    let window_logic = function () {
        let requested_window_index;
        for (let i = 0; i < windows.length; i++) {
            let window = windows[i];
            window.update_logic();
            if (window.dead === true) {
                window.kill();
                windows.splice(i, 1);
            }
            if (window.request_focus === true) {
                requested_window_index = i;
                window.request_focus = false;
            }
        }
        if (requested_window_index !== undefined) {
            for (let i = 0; i < windows.length; i++) {
                windows[i].request_focus = false;
                windows[i].has_focus = false;
            }
            windows[requested_window_index].has_focus = true;
            let window = windows[requested_window_index];
            windows.splice(requested_window_index, 1);
            windows.push(window);
        }
    }
    let window_manager = function () {
        window_logic();
        graphics.drawImage(bg_canvas, 0, 0);
        for (let i = 0; i < windows.length; i++)
            windows[i].draw(graphics, foreground_graphics);
        graphics.drawImage(foreground_graphics.canvas, 0, 0);
        {
            let devices = get_devices();
            graphics.translate(devices.mouse.x, devices.mouse.y);
            cursor_handler(graphics);
            graphics.translate(-devices.mouse.x, -devices.mouse.y);
        }
        let time_buffer = performance.now();
        wm_round_trip = time_buffer - time_marker;
        time_marker = time_buffer;
        performance_display();

        sleep(1000 / monitor_refresh_rate);
    }
    create_init(window_manager);
}const play_startup = false;
//Window manager intialization
//Glass UI
// set_alpha(0.9);
//Mouse cursor
function colorBlackCursor(graphics) {
  graphics.strokeStyle = 'white';
  graphics.fillStyle = 'black';
}
function colorWhiteCursor(graphics) {
  graphics.strokeStyle = 'black';
  graphics.fillStyle = 'white';
}
function simpleCursor() {
  //BETA mouse cursor
  graphics.ellipse(0, 0, 10);
}
function macCursor() {
  strokeWeight(1.4);
  beginShape();
  //Base (left)
  vertex(0, 0);
  vertex(0, 19);
  //Handle (left)
  vertex(4, 15);
  //Handle base (l/r)
  vertex(7, 22);
  vertex(11, 20);
  //Handle (right)
  vertex(8, 14);
  //Base (right)
  vertex(13, 14);
  vertex(0, 0);
  endShape();
}
function winCursor() {
  strokeWeight(1);
  beginShape();
  //Base (left)
  vertex(0, 0);
  vertex(0, 16);
  //Handle (left)
  vertex(4, 13);
  //Handle base (l/r)
  vertex(6, 18);
  vertex(9, 17);
  //Handle (right)
  vertex(7, 12);
  //Base (right)
  vertex(12, 12);
  vertex(0, 0);
  endShape();
}
function winCursorOG() {
  strokeWeight(0.8);
  beginShape();
  //Base (left)
  vertex(0, 0);
  vertex(0, 16);
  //Handle (left)
  vertex(3, 12);
  //Handle base (l/r)
  vertex(6, 20);
  vertex(9, 19);
  //Handle (right)
  vertex(6, 11);
  //Base (right)
  vertex(11, 11);
  vertex(0, 0);
  endShape();
}
let kCursor = graphics => {
  graphics.lineJoin = 'round';
  graphics.lineWidth = 1;
  graphics.beginPath();
  //Base (left)
  graphics.moveTo(0, 0);
  graphics.lineTo(0, 13);
  //Handle (left)
  graphics.lineTo(3, 10);
  //Handle base (l/r)
  graphics.lineTo(5, 15);
  graphics.lineTo(8, 14);
  //Handle (right)
  graphics.lineTo(6, 9);
  //Base (right)
  graphics.lineTo(10, 9);
  graphics.lineTo(0, 0);

  graphics.fill();
  graphics.stroke();
}
let cursorColor = 
  colorBlackCursor
  // colorWhiteCursor
  ;
let cursorShape =
  //Ranked from worst to best :P
  // simpleCursor
  // winCursor
  // winCursorOG
  // macCursor
  kCursor
  ;
let renderMouseCursor = graphics => {
  cursorColor(graphics);
  cursorShape(graphics);
}
//Use kwm as the mouse cursor rendering engine
set_cursor(renderMouseCursor);

//Applications
//Icon creation function
let icons = [];
function createIcon(iconFunction, x, y, size, create_windowFunction) {
  var icon = spawn_window([], "icon");
  let iconRender = spawn_process(() => {
    try{
      graphics.clearRect(0, 0, canvas.width, canvas.height);
      iconFunction(canvas, graphics);  
    } catch (e){
      console.error(e);
    }
    sleep(15);
  });
  let iconKiller = spawn_process(() => {
    if(icon.fade === 1){
      icon.dead = true;
    }
    sleep(100);
  });
  icons.push({
    x: x, 
    y: y,
    size: size,
    window_function: create_windowFunction
  });


  icon.processes_buffer = [iconRender, iconKiller];
  icon.original_processes = [iconRender, iconKiller];
  icon.x = x;
  icon.y = y;
  icon.canvas.width = size;
  icon.canvas.height = size;
  icon.title_bar_height = 0;
  icon.focusable = false;
  icon.foreground = true;
  icon.initialize();

  push_window(icon);
}
let icond = function() {
  for(let i = 0; i < icons.length; i++){
    let icon = icons[i];
    let devices = get_devices();
    if(devices.mouse.x > icon.x && devices.mouse.x < icon.size + icon.x && devices.mouse.y > icon.y && devices.mouse.y < icon.size + icon.y && buttonClicked === false && devices.mouse.clicked){
      try {
        icon.window_function();
      } catch (e) {
        console.error(e);
        icons.splice(i, 1);
      }
      buttonClicked = true;
    }
  }
  sleep(40);
}
create_init(icond);

//Rayhamburger
function rainbow() { }
rainbow.prototype.iconFunction = function (canvas, graphics) {
  graphics.fillStyle = "#FF6464";
  graphics.fillRect(0,0,canvas.width,canvas.height/3);
  graphics.fillStyle = "#64FF64";
  graphics.rect(0,canvas.height/3,canvas.width,canvas.height/3);
  graphics.fillStyle = "#6464FF";
  graphics.rect(0,canvas.height*(2/3),canvas.width,canvas.height/3);
}
rainbow.prototype.create_window = function () {
  quick_window(RenderRainbow, "Rainbow (not gay)");
}

//Add applications
addApplicationFromClass(TTY);//JSTerm
addApplicationFromClass(Settings);//Settings
addApplicationFromClass(SOTF);//Survival of the Fittest
addApplicationFromClass(Octane);//Game Engine
addApplicationFromClass(Paint);//Physics
addApplicationFromClass(Physics);//Physics
addApplicationFromClass(RayCast);//Physics
addApplicationFromClass(CookieClicker);//Cookie Clicker
addApplicationFromClass(Gcode);//Gcode
addApplicationFromClass(SystemMonitor);//System Monitor
addApplicationFromClass(Autoclick);//Autoclicker
//addApplicationFromClass(Rayham);//Raycast
addApplicationFromClass(rainbow);//Render Rainbow
//App Dock
class appDock{
  constructor () {
    this.iconSize = 96;
    this.iconPadding = this.iconSize / 8;
    this.pressed = false;
  }
  createIcons () {
    for (let i = 0; i < applications.length; i++) {
      let iconX = canvas.width / 2 + (this.iconSize + this.iconPadding) * i - applications.length * this.iconSize / 2;
      let iconY = canvas.height - this.iconSize - this.iconPadding*2;
      var self = this;
      create_timeout(() => { createIcon(applications[i].icon, iconX, iconY,
        self.iconSize,applications[i].handler) }, 500 + (90 * i));
    }
  }
}
var appDockSystem = new appDock();
//Background
RenderRainbow = (canvas, graphics) => {
  let gradient = graphics.createLinearGradient(0, 0, canvas.width, canvas.height);
  gradient.addColorStop("0", "red");
  gradient.addColorStop("0.17", "orange");
  gradient.addColorStop("0.33", "yellow");
  gradient.addColorStop("0.5", "green");
  gradient.addColorStop("0.67" ,"blue");
  gradient.addColorStop("0.83" ,"indigo");
  gradient.addColorStop("1.0", "purple");

  graphics.fillStyle = gradient;
  graphics.fillRect(0, 0, canvas.width, canvas.height);
  graphics.font = "48px Arial";
  graphics.fillStyle = "black";
  graphics.fillText("(Not gay)", canvas.width/2 - graphics.measureText("(Not gay)").width/2, 80);
}
function BandaiNamco (canvas, graphics) {
  this.resolutionScale = 1;
  graphics.strokeStyle = 'white';
  for (var i = 0; i < canvas.height; i += this.resolutionScale) {
    var heightScale = i * (510 / canvas.height);
    graphics.fillStyle = `rgb(
      ${heightScale / 2},
      ${100 - (heightScale / 2)},
      ${255 - (heightScale / 2)}`;
    graphics.fillRect(0, i, canvas.width, this.resolutionScale * 2);
  }
}
creasedJacket = (canvas, graphics) => {
  let gradient = graphics.createLinearGradient(0, 0, 0, canvas.height);
  gradient.addColorStop("0", "red");
  gradient.addColorStop("0.5" ,"purple");
  gradient.addColorStop("1.0", "aqua");
  graphics.fillStyle = gradient;
  graphics.fillRect(0, 0, canvas.width, canvas.height);
}

let epic = (canvas, graphics) => {
  let gradient = graphics.createLinearGradient(0, 0, 0, canvas.height);
  gradient.addColorStop("0", "white");
  // gradient.addColorStop("0.5" ,"purple");
  gradient.addColorStop("1.0", "gray");
  graphics.fillStyle = gradient;
  graphics.fillRect(0, 0, canvas.width, canvas.height);
}

GenericBackground = (canvas, graphics) => {
  graphics.fillStyle = "gray";
  graphics.fillRect(0, 0, canvas.width, canvas.height);
  // console.log(graphics.fillStyle)
}
// backgroundFunction = RenderRainbow;
// backgroundFunction = GenericBackground;
// backgroundFunction = imageBackground;
// backgroundFunction = BandaiNamco;
backgroundFunction = creasedJacket;
backgroundFunction = epic;
createBackgroundWindow = () => {
  // let backgroundCanvas = document.createElement("canvas");
  // backgroundCanvas.width = canvas.width;
  // backgroundCanvas.height = canvas.height;
  // let backgroundCanvasGraphics = backgroundCanvas.getContext("2d");
  // backgroundFunction(backgroundCanvas, backgroundCanvasGraphics);

  set_background(backgroundFunction);

  // wmBackgroundGraphics.drawImage(backgroundCanvas, 0, 0);
  setTheme();
}

function kshellErrorScreenDaemon (process, error) {
    let self = this;
    graphics.save();
    if (this.init === undefined) {
        for (var i = 0; i < processes.length; i++) {
            processes[i].manualSuspend = true;
        }
        this.init = true;
    }
    function returnSystem() {
        for (var i = 0; i < processes.length; i++) {
            processes[i].manualSuspend = false;
        }
        systemError = [];
        self.init = undefined;
    }
    graphics.fillStyle = "#FF3333";
    graphics.fillRect(0, 0, canvas.width, canvas.height);
    graphics.font = "16px Monospace";
    graphics.fillStyle = 'black';
    graphics.fillText("Your system has encountered an error.", 10, canvas.height / 4);
    graphics.fillText("To ignore the error and continue to use the system, press [SPACE BAR].", 10, canvas.height / 3);
    graphics.fillText("To kill the process and return to your system, press [Q].", 10, canvas.height / 2.7);
    graphics.fillText(error, 10, canvas.height / 1.5);
    graphics.fillText("Process ID: " + process.PID, 10, canvas.height / 1.2);
    graphics.fillText("Check console for more details.", 10, canvas.height / 1.4);
    let devices = get_devices();
    if (devices.keyboard.keyCodes[81]) {
        kill(process.PID);
        returnSystem();
    } else if (devices.keyboard.keyCodes[32]) {
      try{
        process.command();
      } catch (processError){
        alert("Process in consistent error. Killing process.");
        kill(process.PID);
      }
      returnSystem();
    }
}
errorScreenFunction = kshellErrorScreenDaemon;

//Create background window
createBackgroundWindow();
//Create dock icons
{
  let shell = function(){
    appDockSystem.createIcons();
    sleep(100);
    exit();
  }
  create_init(shell);  
}
//Play startup sound
if(play_startup === true)
  play_sound("desktop/assets/startup.ogg");

//Create functions for each set of processes
function updateAppDockSystem() {
  appDockSystem.update();
}
        </script>
    </body>
</html>