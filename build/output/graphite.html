<!DOCTYPE html>
<!-- Generated by JSLinker -->
<meta name="viewport" content="width=device-width, initial-scale=1">
<html lang="en-US">
    <meta charset="UTF-8">
    <head>
        <title>
Graphite

        </title>
    </head>
    <body>
        <script>
var System = {
    version: "1.0-alpha-1",
    name: "Graphite",
}/* Goals:
- Make Device a class and make an array called "devices" where all devices can be interfaced.
- Preferibly, devices would be divided into devices.keyboard, devices.mouse, devices.gamepad, etc.
/* Fully compatible with the JSOKS (Javascript Octane Kernel Structure) standard */

//Option Variables
let targetCyclesPerSecond = 60;
let preemptiveKernel = true;
let trackProcessPerformance = true;
let idleSuspend = true;
let showPerformanceInfo = true;
let enableWatchdog = true;

//Kernel objects
var Kernel = {
    id: System.name + " Kernel",
    version: System.version,
    capibilities: [
        "Preemptive",
        "Scheduler",
        "Performance Tracking",
        "Power States",
        "Live Reclocking",
    ]
}

//Performance numbers
const startupTime = Date.now();
const targetKernelLatency = 1000 / targetCyclesPerSecond;
let systemExecutionLatency = targetKernelLatency;
let kernelExecutionCycleCount = 0;
let kernelCycleLatency = 0;
let kernelCyclesPerSecond = 0;
const performanceSampleSize = Math.max(Math.round(targetCyclesPerSecond / 10), 1);
function kernelLatencyReporter() {
    const dividedCycleCounter = kernelExecutionCycleCount % (performanceSampleSize * 2);
    if (dividedCycleCounter === 0) {
        this.time1 = performance.now();
    }
    if (dividedCycleCounter === performanceSampleSize) {
        this.time2 = performance.now();
    }
    kernelCycleLatency = Math.abs(this.time1 - this.time2) / performanceSampleSize;
    if (!kernelCycleLatency) {
        kernelCycleLatency = 1;
    }
    kernelCyclesPerSecond = Math.floor(1000 / kernelCycleLatency);

    kernelExecutionCycleCount++;
}
function trackPerformance(command) {
    let timeBefore = performance.now();
    command();
    return performance.now() - timeBefore;
}

//Power state
let kernelPowerState = 0;
let kernelPowerStateManuallySet = false;
function setPowerState(powerState) {
    //Kernel will run at a clock of (2^powerstate)ms
    kernelPowerStateManuallySet = true;
    kernelPowerState = powerState;
}
function resetPowerState() {
    kernelPowerStateManuallySet = false;
    kernelPowerState = 0;
}

//Logs
let kernelLogs = [];
function LogObject(message, severity) {
    this.time = Date.now() - startupTime;

    this.message = message;
    this.severity = severity;
}
function kernelLog(message, severity) {
    let currentSeverity = "info";
    if (severity !== undefined) {
        currentSeverity = severity;
    }
    kernelLogs.push(new LogObject(message, currentSeverity));
}
function printKernelLogs(severity) {
    function printKernelMessage(logObject) {
        return "[" + logObject.time + "]: " + logObject.message;
    }
    console.warn("Kernel log print triggered: ")
    for (let i = 0; i < kernelLogs.length; i++) {
        switch (kernelLogs[i].severity) {
            case "info":
                console.log(printKernelMessage(kernelLogs[i]));
                break;
            case "warning":
                console.warn(printKernelMessage(kernelLogs[i]));
                break;
            case "error":
                console.error(printKernelMessage(kernelLogs[i]));
                break;
            default:
                console.log(printKernelMessage(kernelLogs[i]));
        }
    }
}

//Processes
let processes = [];
let PIDs = 0;
let systemSuspend = false;
class Process {
    constructor(command, priority) {
        //Essential process traits
        this.command = command;
        this.PID = PIDs;
        this.processName = command.name;
        //Performance Tracking
        this.trackPerformance = trackProcessPerformance;
        this.frametime = 0;
        this.cycleCount = 0;
        //Suspend
        this.suspend = false;
        this.manualSuspend = false;
        //Scheduler variables
        let currentPriority = 1;
        if (priority !== undefined) {
            currentPriority = priority;
        }
        this.priority = currentPriority;
        //Misc
        this.startTime = Date.now() - startupTime;
        PIDs++;
    }
    update() {
        if (this.suspend === false && this.manualSuspend === false) {
            if (this.trackPerformance === false) {
                this.command();
                this.cycleCount++;
            } else {
                trackPerformance(this.command);
                this.cycleCount++;
            }
        }
    }
};
function createProcess(command, priority) {
    processes.push(new Process(command, priority));
}
function kill(PID) {
    for (let i = 0; i < processes.length; i++) {
        if (processes[i].PID === PID) {
            processes.splice(i, 1);
            kernelLog("Process " + PID + " killed", "warning");
        }
    }
}
function suspend(PID) {
    for (let i = 0; i < processes.length; i++) {
        if (processes[i].PID === PID) {
            processes[i].manualSuspend = true;
            kernelLog("Process " + PID + " suspended", "warning");
        }
    }
}
function resume(PID) {
    for (let i = 0; i < processes.length; i++) {
        if (processes[i].PID === PID) {
            processes[i].manualSuspend = false;
            processes[i].suspend = false;
            kernelLog("Process " + PID + " resumed", "warning");
        }
    }
}
let systemError = [];
function runProcess(process) {
    try {
        process.update();
    } catch (error) {
        console.error("Process with PID " + process.PID + " encountered an error.");
        console.error(error);
        kernelLog("Process with PID " + process.PID + " failed to run: " + error, "error");
        systemError = [true, process, error];
    }
}
let kernelProcessLoopIndex = 0;
let kernelProcessExecutionLatency = targetKernelLatency;
let kernelProcessesIndexes = [];
let kernelProcessesLoopsPerSecond = 0;
function sortKernelProcesses() {
    kernelProcessesIndexes = [];
    for (let i = 0; i < processes.length; i++) {
        kernelProcessesIndexes[i] = {
            index: i,
            priority: processes[i].priority
        };
    }
    kernelProcessesIndexes = kernelProcessesIndexes.sort((a, b) => (b.priority - a.priority));
    for (let i = 0; i < kernelProcessesIndexes.length; i++) {
        kernelProcessesIndexes[i] = kernelProcessesIndexes[i].index;
    }
}
function updateKernelProcesses() {
    /* Scheduler
    Executioner idea: 
    - Run processes until the time that the while loop has been running is greater than or equal to the target loop cycle rate.
    - Give each process a "chunk" of the frametime and give higher priority processes bigger chunks. Do this by pausing and resuming tasks when the time is right.
    - Determine how much "chunk" each process should get based on priority.
    - Only call the scheduler when it is needed and update variables only when necessary
    - Progress through each process as the seconds carry on.
    Prioritize tasks: 
    - Higher number = better
    - Any range of numbers work.
    */
    if (systemSuspend === false && systemError[0] !== true && processes.length > 0) {
        let timeBefore = performance.now();
        //Sort processes by priority depending on if the kernel is preemtive
        if (preemptiveKernel === true) {
            if (kernelProcessesIndexes === undefined || kernelProcessesIndexes.length !== processes.length) {
                sortKernelProcesses();
            }
            let loopCycleCount = 0;
            let loopCondition = true;
            const adjustedTargetLatency = (Math.floor(targetKernelLatency) - (systemExecutionLatency - kernelProcessExecutionLatency));
            while (loopCondition === true) {
                //Scheduler code
                const frameEndTime = adjustedTargetLatency - (performance.now() - timeBefore);
                if (frameEndTime <= 0) {
                    loopCondition = false;
                    break;
                }
                if (loopCycleCount >= processes.length) {
                    loopCondition = false;
                    break;
                }
                //Process running
                let currentProcess = processes[kernelProcessesIndexes[kernelProcessLoopIndex]];
                if (currentProcess === undefined) {
                    sortKernelProcesses();
                    break;
                }
                if (currentProcess.dead === true) {
                    processes.splice(kernelProcessLoopIndex, 1);
                    break;
                }
                if (currentProcess.frametime + 1 > frameEndTime) {//Predict if the next process is going to go over the frame.
                    if (loopCycleCount > 0) {
                        break;
                    } else {
                        runProcess(currentProcess);
                    }
                } else {
                    runProcess(currentProcess);
                }
                loopCycleCount++;
                kernelProcessLoopIndex++;
            }
            // kernelProcessesLoopsPerSecond = loopCycleCount;
            if (kernelProcessLoopIndex >= processes.length) {
                kernelProcessLoopIndex = 0;
            }
        } else {
            //Non-preemptive
            for (let i = 0; i < processes.length; i++) {
                if (processes[i].dead === true) {
                    processes.splice(i, 1);
                    break;
                }
                runProcess(processes[i]);
            }
        }
        kernelProcessExecutionLatency = performance.now() - timeBefore;
    }
}

//Input management
let devices = {};
//Mouse
devices.mouse = {
    x: 0,
    y: 0,
    vectorX: 0,
    vectorY: 0,
    clicked: false
};
document.onmousemove = event => {
    devices.mouse.vectorX = devices.mouse.x - event.pageX;
    devices.mouse.vectorY = devices.mouse.y - event.pageY;
    devices.mouse.x = event.pageX;
    devices.mouse.y = event.pageY;
};
document.onmousedown = () => {
    devices.mouse.clicked = true;
    devices.mouse.pressed = true;
};
document.onmouseup = () => {
    devices.mouse.clicked = false;
    devices.mouse.pressed = false;
};
//Keyboard
devices.keyboard = {
    keys: [],
    keyCodes: [],
    pressed: false,
    keyCode: 0,
    info: {},
};
devices.keyboard.keyCodes = [];
document.onkeydown = event => {
    devices.keyboard.keyCodes[event.keyCode] = true;
    devices.keyboard.keys.push(event.key);
    devices.keyboard.pressed = true;
    devices.keyboard.info = event;
};
document.onkeyup = event => {
    devices.keyboard.keyCodes[event.keyCode] = false;
    devices.keyboard.pressed = false;
    devices.keyboard.info = event;
};
function keyboardConfigurationDaemon() {
    devices.keyboard.keys = [];
}
//Controllers
devices.controllers = [];
window.addEventListener("gamepadconnected", e => {
    kernelLog("Device: Controller " + e.gamepad.index + " connected (" + e.gamepad.id + ")", "info");
    devices.controllers.push(e.gamepad);
});
window.addEventListener("gamepaddisconnected", e => {
    kernelLog("Device: Controller " + e.gamepad.index + " disconnected (" + e.gamepad.id + ")", "info");
    devices.controllers.splice(e.gamepad, 1);
});

//System suspend
function suspendSystem(processesArray) {
    for (let i = 0; i < processesArray.length; i++) {
        processesArray[i].suspend = true;
    }
    kernelLog("System has been suspended.", "warning");
}
function resumeSystem(processesArray) {
    for (let i = 0; i < processesArray.length; i++) {
        processesArray[i].suspend = false;
    }
    kernelLog("System has been resumed.", "warning");
}

//Kernel panic
let panicProcesses = [];
let panicWindow = [];
function panic(message) {
    let panicMessage = "A kernel panic has occured. System is unusable.";
    if (message !== undefined) {
        panicMessage = message;
    }
    enableWatchdog = false;
    console.error(panicMessage);
    kernelLog("FATAL - Kernel Panic (" + panicMessage + ")", "error");

    panicProcesses = processes;
    kernelLog("Check the panicProcesses variable for the process state before the system went down.", "info");
    panicProcesses = processes;
    kernelLog("Check the panicWindow for the window state before the system went down.", "info");

    processes = [];
    printKernelLogs();

    canvas = null;
    monitorFramerate = null;
    alert("Kernel panic: " + panicMessage);
}

//Kernel watchdog
let watchdogCycleCountBuffer = 0;
let watchdogSafetyTimer = 0;
let watchdogHangTimer = false;
let kernelWatchdogTriggerCount = 0;
function watchdog() {
    if (enableWatchdog === true) {
        if (kernelExecutionCycleCount === watchdogCycleCountBuffer && watchdogHangTimer === false) {
            kernelLog("Watchdog: Kernel watchdog timer triggered", "warning")
            watchdogSafetyTimer = Date.now();
            watchdogHangTimer = true;
            kernelWatchdogTriggerCount++;
        } else if (kernelExecutionCycleCount !== watchdogCycleCountBuffer) {
            watchdogCycleCountBuffer = kernelExecutionCycleCount;
            watchdogHangTimer = false;
        }
        if (watchdogHangTimer === true && Date.now() - watchdogSafetyTimer >= 4300) {
            panic("Kernel watchdog has detected that your system is hung.");
        }
        if (kernelWatchdogTriggerCount > 5) {
            kernelLog("Watchdog: The watchdog has been called many times. The system is freezing a lot. Are there heavy processes running?", "warning");
        }
    }
}
setInterval(() => { watchdog() }, 2500);//run kernel watchdog every 2.5 seconds

//Kernel reset
function resetKernel() {
    let processesBuffer = [];
    for (let i = 0; i < processes.length; i++) {
        processesBuffer[i] = new Process(processes[i].command, processes[i].priority);
    }
}

//Graphics
let canvas = document.createElement("canvas");
if (!canvas) {
    kernelLog("Graphics: Failed to create canvas.", "error");
}
let graphics = canvas.getContext('2d');
if (!graphics) {
    kernelLog("Graphics: Failed to load 2d context.", "error");
}
let webgl = canvas.getContext('webgl');
if (!webgl) {
    kernelLog("Graphics: Failed to load webgl context.", "warning");
}
canvas.id = "canvas";
canvas.width = window.innerWidth - 20;
canvas.height = window.innerHeight - 21;
document.body.appendChild(canvas);

//Error screen daemon
let errorScreenFunction = (process, processError) => {//Default error
    let killConfirmation = confirm("Process " + process.PID + " encountered an error: --> " + processError + " <-- Attempting to kill the errored process.");
    if (killConfirmation === false) {
        try {
            process.command();
        } catch (error) {
            alert("Process " + process.PID + " failed to run again. Killing process.");
            console.error(error);
            kill(process.PID);
        }
    } else {
        kill(process.PID);
    }
    systemError = [];
};
function errorScreenDaemon() {
    if (systemError[0] === true) {
        errorScreenFunction(systemError[1], systemError[2]);
    }
}

//Performance Display
let performanceDisplayFunction = () => {
    //TODO: Add performance display for native kernel
};
function performanceDisplay() {
    if (showPerformanceInfo === true) {
        performanceDisplayFunction();
    }
}

//System suspend daemon. Responsible for suspending on inactivity/unfocused and with keyboard shortcut.
let mouseInactivityTimer = 0;
let systemKeySuspended = false;
function suspendResponseDaemon() {
    //Inactivity suspend
    if (idleSuspend === true) {
        if (devices.mouse.vectorX === 0 && devices.mouse.vectorY === 0 && !devices.keyboard.pressed && !devices.mouse.pressed) {
            mouseInactivityTimer += systemExecutionLatency / 1000;
        }
        if (document.hasFocus()) {
            mouseInactivityTimer = 0;
            if (this.inactive === true) {
                systemSuspend = false;
                kernelLog("System has been resumed from inactivity.", "info");
                this.inactive = undefined;
            }
        }
        if (mouseInactivityTimer > 30 && this.inactive === undefined || !document.hasFocus() && this.inactive === undefined) {
            systemSuspend = true;
            this.inactive = true;
            kernelLog("System has been suspended due to inactivity.", "info");
        }
    }
    //Suspend keyboard shortcut
    if (devices.keyboard.keyCodes[192] && this.suspended === undefined) {
        systemSuspend = true;
        this.suspended = true;
        kernelLog("System has been manually suspended.", "warning");
    }
    if (this.suspended && devices.keyboard.keyCodes[192] !== true) {
        systemKeySuspended = true;
        if (devices.keyboard.info.pressed) {
            systemSuspend = false;
            this.suspended = undefined;
            systemKeySuspended = false;
            kernelLog("System has been manually resumed.", "warning");
        }
    }
    if (systemSuspend === true) {
        kernelPowerState = 7;
    } else if (kernelPowerStateManuallySet === false) {
        kernelPowerState = 0;
    }
}


/* Create process example:
createProcess(command, priority);
createProcess(foo, 1);
createProcess(foo1, 0);
createProcess(foo2, 0);
*/


//Kernel loop
let kernelLoopTimeoutId;
let loopKernel = true;
function stopKernelLoop() {
    clearTimeout(kernelLoopTimeoutId);
    loopKernel = false;
}
function executeKernel() {
    try {
        let timeBefore = performance.now();
        //Suspend hotkey daemon
        suspendResponseDaemon();
        //Update processes
        updateKernelProcesses();
        //Error screen daemon
        errorScreenDaemon();
        //Run keyboard daemon
        keyboardConfigurationDaemon();

        //Calculate and report latency
        kernelLatencyReporter();
        //Show performance info
        performanceDisplay();
        //Report performance
        systemExecutionLatency = performance.now() - timeBefore;
        //Set an asynchronous timeout so the kernel executes itself again
        kernelLoopTimeoutId = setTimeout(executeKernel, Math.pow(2, kernelPowerState));
    } catch (error) {
        console.error(error);
        clearTimeout(kernelLoopTimeoutId);
        panic("Kernel encountered a fatal error. System unusable.");
    }
}
if (loopKernel === true) {
    executeKernel();//Run the kernel
}//Option variables

//Process performance information
function totalFrametimes(processesArray) {
    let currentProcessesArray = processes;
    if (processesArray) {
        currentProcessesArray = processesArray;
    }
    //Get total frametimes from all processes
    let totalFrametime = 0;
    for (let i = 0; i < currentProcessesArray.length; i++) {
        let currentProcess = currentProcessesArray[i];
        if (!currentProcess.suspend && !currentProcess.manualSuspend) {
            totalFrametime += currentProcess.frametime;
        }
    }
    return totalFrametime;
}

//Process information gathering
Process.prototype.getInfo = function () {
    let attributes = [];
    attributes.push("Name: " + this.name);
    attributes.push("PID: " + this.PID);
    attributes.push("Priority: " + this.priority);
    attributes.push("Frametime: " + this.frametime);
    attributes.push("Execution Ratio: " + this.execRatio);
    return attributes;
};
function PIDfind(PID) {
    let foundProcess;
    for (let i = 0; i < processes.length; i++) {
        let currentProcess = processes[i];
        if (PID === currentProcess.PID) {
            foundProcess = currentProcess;
        }
    }
    return foundProcess;
}
function info(PID) {
    return PIDfind(PID).getInfo();
}
function find(processName) {
    let foundProcesses = [];
    for (let i = 0; i < processes.length; i++) {
        let currentProcess = processes[i];
        if (processName === currentProcess.processName) {
            foundProcesses.push(currentProcess.PID);
        }
    }
    return foundProcesses;
}

//Process tools
function killall(processName) {
    let processNames = find(processName);
    for (let i = 0; i < processNames.length; i++) {
        kill(processNames[i]);
    }
}

//Kernel state
function reloadKernel(){
    try{
        for(var i = 0; i < processGroups.length; i++){
            resetSystem(processGroups[i]);
        }
        processes = resetSystem(processes);
        setup();
        console.log("Kernel successfully reloaded.");
    } catch {
        console.error("Kernel failed to reload.");
    }
}
function getTransition(size, time){
    return (Math.abs(size) / kernelCyclesPerSecond) * (1000 / time);
}
function downloadKernelState() {
    var hiddenElement = document.createElement('a');
  
    hiddenElement.href = 'data:attachment/text,' + encodeURI(processGroups);
    hiddenElement.target = '_blank';
    hiddenElement.download = 'state.oks';
    hiddenElement.click();
}
function loadKernelState(){
    var input = document.createElement('input');
    input.type = 'file';

    input.onchange = e => {
        processGroups = e.target.files[0]; 
    }

    input.click();
}
performanceDisplayFunction = () => {
    graphics.save();
    graphics.fillStyle = '#AAAAAA';
    graphics.fillRect(0, 0, 38, 30);
    graphics.strokeStyle = 'black';
    graphics.fillStyle = 'black';
    graphics.font = '14px Monospace';
    graphics.fillText(Math.round(kernelCyclesPerSecond), 10, 19);

    graphics.translate(38,0)
    graphics.fillStyle = '#EEAAAA';
    graphics.fillRect(0, 0, 38, 30);
    graphics.fillStyle = 'black';
    graphics.fillText(Math.round(kernelCycleLatency), 10, 19);
    graphics.restore();
};var animateSystem = true;
var buttonClicked = false;
var listViewOpened = "";

//Color scheme
let colorScheme;
{
    let accent = '#466EFF';
    let background = "#808080";
    let dialogueBackground = "#1E1E1E";
    let elementColors = "#1E1E1E";
    let textColor = "white";
    colorScheme = [
        accent,
        background,
        dialogueBackground,
        elementColors,
        textColor,
    ];
}

function centerText(graphics, displayText, textX, textY, textW, textH, textStyle) {
    let currentTextStyle = 12;
    if (textStyle) {
        currentTextStyle = textStyle;
    }
    graphics.font = currentTextStyle + "px Monospace";
    const textDisplayX = textX + ((textW / 2) - (graphics.measureText(displayText).width / 2));
    const textDisplayY = textY + ((textH / 2) + (currentTextStyle / 3));
    graphics.fillText(displayText, textDisplayX, textDisplayY);
}
function simpleCenterText(graphics, displayText, textX, textY){
    graphics.fillText(displayText, textX - textWidth(displayText)/2, textY);
}
function blankButton(x, y, w, h, func){
    if (devices.mouse.x > x && devices.mouse.x < x + w && devices.mouse.y > y && devices.mouse.y < y + h && devices.mouse.clicked && buttonClicked === false) {
        func();
        buttonClicked = true;
    }
}
function Button(graphics, x, y, w, h, func) {
    graphics.save();
    if (devices.mouse.x > x && devices.mouse.x < x + w && devices.mouse.y > y && devices.mouse.y < y + h) {
        graphics.strokeStyle = colorScheme[0];
        graphics.lineWidth = 1.8;

        if(devices.mouse.clicked && buttonClicked === false){
            func();
            buttonClicked = true;
        }
    }
    graphics.fillStyle = colorScheme[3];
    
    graphics.beginPath();
    graphics.lineTo(x,y);
    graphics.lineTo(x+w, y);
    graphics.lineTo(x+w,y+h);
    graphics.lineTo(x,y+h);
    graphics.lineTo(x,y);
    graphics.fill();
    graphics.stroke();
    graphics.restore();
}
function labledButton(graphics, x, y, w, h, func, buttonText, textStyle, textColor){
    if(!textColor){
        Button(graphics, x, y, w, h, func);
        graphics.fillStyle = colorScheme[4];
    }else{
        Button(graphics, x, y, w, h, func, false);
        graphics.fillStyle = textColor;
    }
    centerText(graphics, buttonText, x, y, w, h, textStyle);
}
function booleanToggleButton(graphics, bool, textFalse, textTrue, x, y, w, h, customFunction, textColor){
    var self = this;
    let currentCustomFunction = customFunction;
    if(!customFunction){
        currentCustomFunction = () => {};
    }
    let result = bool;
    function changeBoolean(){
        if(!bool){
            result = true;
            currentCustomFunction(bool);
            return;
        }
        if(bool){
            result = false;
            currentCustomFunction(bool);
            return;
        }
    }
    graphics.save();
    if(bool === false){
        labledButton(graphics, x, y, w, h, changeBoolean, textFalse, textColor);
    }
    if(bool === true){
        labledButton(graphics, x, y, w, h, changeBoolean, textTrue, textColor);
    }
    graphics.restore();
    return result;
}
function listSelector(graphics, variable, options, x, y, w, h, text, textColor){
    let result = variable;
    function openMenu(){
        listViewOpened = text;
        this.mouseClickedX = devices.mouse.x;
        this.mouseClickedY = devices.mouse.y;
    }
    graphics.save();
    if(listViewOpened === text){
        let menuClicked = false;
        for(var i = 0; i < options.length; i++){
            graphics.save();
            graphics.fillStyle = 'white';
            labledButton(graphics, x, y + (h*i), w, h, () => {
                result = options[i][0];
                listViewOpened = "";
                menuClicked = true;
            }, options[i][1], 'black');
            graphics.restore();
        }
    }
    if(listViewOpened.length < 1){
        labledButton(graphics, x, y, w, h, openMenu, text, textColor);
    }
    graphics.restore();
    return result;
}
//Reset button clicked status
function jtk(){
    if(devices.mouse.clicked === false){
        buttonClicked = false;
    }
}
//Animation handler
function animateAcceleration(value, targetSize, time) {
    if(animateSystem === true){
        if (Math.round(value) !== targetSize) {
            return getTransition(targetSize - value, time, true);
        } else {
            return 0;
        }
    }else{
        return targetSize - value;
    }
}

createProcess(jtk, -1);class Settings {
    update (canvas, graphics){
        //App background
        graphics.fillStyle = "black";
        graphics.fillRect(0,0,canvas.width,canvas.height);

        graphics.fillStyle = "#282828";
        //Settings
        showPerformanceInfo = booleanToggleButton(graphics, showPerformanceInfo, "Turn on FPS display", "Turn off FPS display", 10, 10, canvas.width-20, 30);
        trackPerformance = booleanToggleButton(graphics, trackPerformance, "Track processes performance", "Untrack processes performance", 10, 50, canvas.width-20, 30, reloadKernel);
        preemptiveKernel = booleanToggleButton(graphics, preemptiveKernel, "Disable preemptive scheduler", "Enable preemptive scheduler", 10, 90, canvas.width-20, 30, reloadKernel);
        // limitFps = booleanToggleButton(graphics, limitFps, "Enable FPS limiter", "Disable FPS limiter", 10, 130, canvas.width-20, 30);
        idleSuspend = booleanToggleButton(graphics, idleSuspend, "Suspend at idle", "Do not suspend at idle", 10, 170, canvas.width-20, 30);
        // displayScaling = booleanToggleButton(graphics, displayScaling, "Scale display", "Do not scale display", 10, 210, canvas.width-20, 30);
        cursorShape = listSelector(graphics, cursorShape, [
            [simpleCursor, "Simple"],
            [winCursor, "Windows"],
            [winCursorOG, "Windows OG"],
            [macCursor, "Mac"],
            [kCursor, "kCursor"],
        ], 10, 250, canvas.width-20, 30, "Cursor Shape");
        cursorColor = listSelector(graphics, cursorColor, [
            [colorWhiteCursor, "White"],
            [colorBlackCursor, "Black"],
        ], 10, 290, canvas.width-20, 30, "Cursor Color");
    }

    iconFunction(canvas, graphics){
        graphics.fillStyle = '#646464';
        graphics.fillRect(0,0,canvas.width,canvas.height, 20);
        graphics.translate(canvas.width/2, canvas.height/2);
        var gearSizeCoefficient = 0.9;
        var scaledWidth = canvas.width * gearSizeCoefficient;
        var scaledHeight = canvas.height * gearSizeCoefficient;
        graphics.fillStyle = "white";
        graphics.ellipse(0,0,scaledWidth/1.5, scaledHeight/1.5, 0, 0, 0);
        //Spokes
        var spokeCount = 20;
        var spokeLengthOffset = 7;
        for(var i = 0; i < 360; i+=360/spokeCount){
            graphics.rotate(i * Math.PI / 180);
            graphics.fillRect(-(scaledWidth/spokeCount)/2, -scaledHeight/2 + spokeLengthOffset, scaledWidth/spokeCount, scaledHeight/2 - spokeLengthOffset, 10);
            graphics.rotate(-i * Math.PI / 180);
        }
        graphics.resetTransform();
    }

    createWindow (){
        var settingsSystem = new Settings();
        quickWindow((canvas,graphics) => {settingsSystem.update(canvas,graphics)}, "Settings");
    }
}
//Survival of the Fittest
/* New features list:
x- Create shop icons
- Fix camera
- Make death screen more useful (with player stats, time alive, etc)
- Ability to aim (with right stick on controller)
- A boss every X rounds
- Fix controller bug where disconnecting just makes your character a potato
- Allow reliable joining mid-game (and have them be revived)
- Day/night cycle (and clouds)
*/
function customRandom(min, max) {
  return Math.random() * (max + Math.abs(min)) - Math.abs(min);
}
function fillPlayerNumber(number) {
  if (!number) {
    fill(170, 170, 170);
  } else {
    switch (number) {
      case 0:
        fill(170, 170, 170);
        break;
      case 1:
        fill(100, 100, 255);
        break;
      case 2:
        fill(255, 100, 100);
        break;
      case 3:
        fill(100, 255, 100);
        break;
      case 4:
        fill(255, 255, 100);
        break;
    }
  }
}
class SOTF {
  constructor() {
    this.players = [];
    this.enemies = [];
    this.world = [];
    this.guns = [];
    this.shopItems = [];

    this.menuState = "start";
    this.startupScreenTimer = 72;
    this.processes = [];
    this.logicProcesses = [];

    //gravityForce is measured in m/s
    //Every 20px is one meter ingame
    this.gravityForce = 9.8;
    this.playerSize = 30;
    this.enemySize = this.playerSize / 1.8;

    this.groundStepHeight = 0.2;
    this.groundStepWidth = 10;
    this.camX = 0;
    this.camY = 0;

    this.controllerDeadzone = 0.1;
    this.playerBuffer = [];
    this.deadPlayers = [];

    this.level = 1;
    this.levelKillGoal = 2;
    this.enemiesKilled = 0;
    this.transitionNextLevel = false;
    this.nextLevelTransitionCounter = 0;
    this.worldGenerationNumber = 0;
  }
  update() {
    let self = this;

    //Guns
    function Gun() {
      this.name = '';
      this.art = () => { };
      this.damage = 0;
      this.spread = 0;
      this.special = false;
      this.automatic = false;
      this.fireCooldown = 0;
    }
    Gun.prototype.pistol = function () {
      this.name = 'pistol';
      this.art = direction => {
        //Do not stroke here;
        fill(50, 50, 50);
        if (direction === 'left') {
          translate(-self.playerSize / 2 + 2, self.playerSize / 2 - 6)
          rect(0, 0, 14, 6);
          rect(8, 5, 6, 7);
        }
        if (direction === 'right') {
          translate(self.playerSize - 1, self.playerSize / 2 - 6)
          rect(0, 0, 14, 6);
          rect(0, 5, 6, 7);
        }
        if (!direction) {
          rect(0, 0, 14, 6);
          rect(0, 5, 6, 7);
        }
      }
      this.damage = 15;
      this.spread = 20;
      this.special = false;
      this.automatic = false;
      this.fireCooldown = 0;
    }
    Gun.prototype.smg = function () {
      this.name = 'smg';
      this.art = direction => {
        //Do not stroke here;
        if (direction === 'left') {
          translate(-self.playerSize / 2 + 15, self.playerSize / 2 - 3);
          scale(0.6)
          fill(87, 76, 76);
          rect(0, 0, -50, 10);
          fill(110, 101, 101);
          rect(-30, 10, -7, 28);
          fill(176, 157, 157);
          rect(-50, 3, -5, 3);
          fill(112, 49, 0);
          rect(-5, 10, -8, 21);
        }
        if (direction === 'right') {
          translate(self.playerSize / 2 + 15, self.playerSize / 2 - 3);
          scale(0.6)
          fill(87, 76, 76);
          rect(0, 0, 50, 10);
          fill(110, 101, 101);
          rect(30, 10, 7, 28);
          fill(176, 157, 157);
          rect(50, 3, 5, 3);
          fill(112, 49, 0);
          rect(5, 10, 8, 21);
        }
        if (!direction) {
          fill(87, 76, 76);
          rect(0, 0, 50, 10);
          fill(110, 101, 101);
          rect(30, 10, 7, 28);
          fill(176, 157, 157);
          rect(50, 3, 5, 3);
          fill(112, 49, 0);
          rect(5, 10, 8, 21);
        }
      };
      this.damage = 13;
      this.automatic = true;
      this.special = false;
      this.fireRate = 17;
      this.spread = 30;
    }
    Gun.prototype.assault = function () {
      this.name = 'assault';
      this.art = direction => {
        //Do not stroke here;
        scale(0.5);
        if (direction === 'left') {
          translate(self.playerSize - 21, self.playerSize / 2 + 10);
          fill(30);
          rect(0, 0, -50, 10);
          fill(135, 71, 2);
          rect(-20, 10, -7, 20);
          fill(30);
          rect(-50, 1, -25, 7);
          fill(135, 71, 2);
          rect(-5, 10, -7, 15);
          rect(25, 0, -25, 6);
          rect(25, 0, -3, 20);
          fill(50);
          rect(-10, -4, -6, 4);
          fill(20);
          rect(-75, 3, -10, 3);
          rect(-85, 2, -6, 5);
        }
        if (direction === 'right') {
          translate(self.playerSize + 20, self.playerSize / 2 + 10);
          fill(30);
          rect(0, 0, 50, 10);
          fill(135, 71, 2);
          rect(20, 10, 7, 20);
          fill(30);
          rect(50, 1, 25, 7);
          fill(135, 71, 2);
          rect(5, 10, 7, 15);
          rect(-25, 0, 25, 6);
          rect(-25, 0, 3, 20);
          fill(50);
          rect(10, -4, 6, 4);
          fill(20);
          rect(75, 3, 10, 3);
          rect(85, 2, 6, 5);
        }
        if (!direction) {
          fill(30);
          rect(0, 0, 50, 10);
          fill(135, 71, 2);
          rect(20, 10, 7, 20);
          fill(30);
          rect(50, 1, 25, 7);
          fill(135, 71, 2);
          rect(5, 10, 7, 15);
          rect(-25, 0, 25, 6);
          rect(-25, 0, 3, 20);
          fill(50);
          rect(10, -4, 6, 4);
          fill(20);
          rect(75, 3, 10, 3);
          rect(85, 2, 6, 5);
        }
      };
      this.damage = 29;
      this.automatic = true;
      this.special = false;
      this.fireRate = 12;
      this.spread = 10;
    }
    Gun.prototype.shotgun = function () {
      this.name = 'shotgun';
      this.art = direction => {
        scale(0.5)
        stroke(0);
        if (direction === 'left') {
          translate(self.playerSize, self.playerSize / 2 + 10)
          fill(40);
          rect(0, 0, -48, 16);
          rect(-114, 1, 60, 5);
          rect(-48, 1, -19, 6);
          rect(-103, 9, 55, 5);
          rect(10, 0, -10, 30);
          fill(30);
          rect(-61, 6, -32, 11);
        }
        if (direction === 'right') {
          translate(self.playerSize, self.playerSize / 2 + 10)
          fill(40);
          rect(0, 0, 48, 16);
          rect(114, 1, -60, 5);
          rect(48, 1, 19, 6);
          rect(103, 9, -55, 5);
          rect(-10, 0, 10, 30);
          fill(30);
          rect(61, 6, 32, 11);
        }
        if (!direction) {
          fill(40);
          rect(0, 0, 48, 16);
          rect(114, 1, -60, 5);
          rect(48, 1, 19, 6);
          rect(103, 9, -55, 5);
          rect(-10, 0, 10, 30);
          fill(30);
          rect(61, 6, 32, 11);
        }
      };
      this.cost = 0;
      this.damage = 13;
      this.spread = 20;
      this.special = true;
    }
    Gun.prototype.sniper = function () {
      this.name = 'sniper';
      this.art = direction => {
        //Do not stroke here;
        scale(0.2);
        if (direction === 'left') {
          translate(self.playerSize - 30, self.playerSize / 2 + 50);
          fill(100);
          rect(0, 0, -200, 20);
          rect(-200, 7, -100, 7);
          rect(60, 0, -80, 6);
          rect(70, 0, -10, 30, 70, 0, 0, 0);
          fill(0);
          rect(-80, -17, -50, 18);
          rect(0, 20, -15, 20);
          rect(-60, 20, -10, 10);
          fill(70);
          rect(-300, 4, -15, 14);
        }
        if (direction === 'right') {
          translate(self.playerSize + 120, self.playerSize / 2 + 50);
          fill(100);
          rect(0, 0, 200, 20);
          rect(200, 7, 100, 7);
          rect(-60, 0, 80, 6);
          rect(-70, 0, 10, 30, 70, 0, 0, 0);
          fill(0);
          rect(80, -17, 50, 18);
          rect(0, 20, 15, 20);
          rect(60, 20, 10, 10);
          fill(70);
          rect(300, 4, 15, 14);
        }
        if (!direction) {
          fill(100);
          rect(0, 0, 200, 20);
          rect(200, 7, 100, 7);
          rect(-60, 0, 80, 6);
          rect(-70, 0, 10, 30, 70, 0, 0, 0);
          fill(0);
          rect(80, -17, 50, 18);
          rect(0, 20, 15, 20);
          rect(60, 20, 10, 10);
          fill(70);
          rect(300, 4, 15, 14);
        }
      }
      this.damage = 35;
      this.spread = 3;
      this.special = false;
      this.automatic = false;
      this.fireCooldown = 0;
    }

    //Player system
    function Player(x, y, controller, playerNumber) {
      this.x = x;
      this.y = y;
      this.health = 100;
      this.maxHealth = 100;

      this.controller = controller;
      this.number = 0;
      if (this.number !== undefined) {
        this.number = playerNumber;
      }

      this.shopButtonPressed = false;
      this.shopMenu = false;

      this.gravity = 0;
      this.horizontalVelocity = 0;
      this.speedMultiplier = 1;

      this.falling = true;
      this.jumping = false;

      this.gun = new Gun();
      this.gun.pistol();
      this.direction = 'left';
      this.gunFired = false;
      this.gunCooldownCounter = 0;
      this.gunShotCount = 0;
      this.shotMultiplier = 1;
      this.damageAdder = 0;

      this.damageDone = 0;
      this.points = 0;
      this.kills = 0;
    }
    //Function for shooting
    function findIntersection(x1, y1, x2, y2, x3, y3, x4, y4) {
      const denominator = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);
      if (denominator !== 0) {
        const t = ((x1 - x3) * (y3 - y4) - (y1 - y3) * (x3 - x4)) / denominator;
        const u = -((x1 - x2) * (y1 - y3) - (y1 - y2) * (x1 - x3)) / denominator;
        return (t > 0 && t < 1 && u > 0);
      } else {
        return false;
      }
    }
    function fireBullet(x, y, dirX, dirY, player) {
      var bulletHit = false;
      for (var i = 0; i < self.enemies.length; i++) {
        var currentEnemy = self.enemies[i];
        let bulletIntersects = false;

        const x3 = x;
        const y3 = y;
        const x4 = x + dirX;
        const y4 = y + dirY;
        //Left side
        var x1 = currentEnemy.x;
        var y1 = currentEnemy.y;
        var x2 = currentEnemy.x;
        var y2 = currentEnemy.y + self.enemySize;

        bulletIntersects = findIntersection(x1, y1, x2, y2, x3, y3, x4, y4);
        //Bottom side
        if (bulletIntersects === false) {
          x1 = currentEnemy.x;
          y1 = currentEnemy.y + self.enemySize;
          x2 = currentEnemy.x + self.enemySize;
          y2 = currentEnemy.y + self.enemySize;

          bulletIntersects = findIntersection(x1, y1, x2, y2, x3, y3, x4, y4);
        }
        //Right side
        if (bulletIntersects === false) {
          x1 = currentEnemy.x + self.enemySize;
          y1 = currentEnemy.y;
          x2 = currentEnemy.x + self.enemySize;
          y2 = currentEnemy.y + self.enemySize;

          bulletIntersects = findIntersection(x1, y1, x2, y2, x3, y3, x4, y4)
        }
        //Top side
        if (bulletIntersects === false) {
          x1 = currentEnemy.x;
          y1 = currentEnemy.y;
          x2 = currentEnemy.x + self.enemySize;
          y2 = currentEnemy.y;

          bulletIntersects = findIntersection(x1, y1, x2, y2, x3, y3, x4, y4);
        }
        if (bulletIntersects === true) {
          var playerDamage = player.gun.damage + player.damageAdder;
          player.damageDone += playerDamage;
          currentEnemy.health -= playerDamage;
          if (currentEnemy.health <= 0) {
            player.points++;
            player.kills++;
            self.enemiesKilled++;
            if (self.enemies.length <= Math.min(self.levelKillGoal - self.enemiesKilled, 1000)) {
              for (var l = 0; l <= Math.round(Math.random()) + 1; l++) {
                self.enemies.push(new Enemy(currentEnemy));
              }
            }
            self.enemies.splice(i, 1);
          }
          bulletHit = true;
        }
      }
      //Draw bullet
      if (bulletHit === false) {
        stroke(90, 90, 255);
      } else {
        stroke(255, 0, 0);
      }
      strokeWeight(3);
      line(x - self.camX, y - self.camY, (x - self.camX) + (dirX * canvas.width), (y - self.camY) + (dirY * canvas.height));
      //Do not stroke here;
      strokeWeight(1);
    }
    //Shop logic
    function ShopItem(cost, handler, compoundRate) {
      this.cost = cost;
      this.handler = handler;
      this.originalPrice = cost;
      this.compoundRate = compoundRate;
    }
    ShopItem.prototype.award = function (player) {
      if (player.points >= this.cost) {
        player.points -= this.cost;
        this.handler(player);
        if (this.compoundRate) {
          this.cost = Math.floor(this.cost * this.compoundRate);
        }
      }
    }
    ShopItem.prototype.resetPrice = function () {
      this.cost = this.originalPrice;
    }
    //Add shop items
    this.shopItems.push([
      new ShopItem(8, player => {
        if (player.health < player.maxHealth) {
          player.health += 20;
          if (player.health > player.maxHealth) {
            player.health = player.maxHealth
          }
        } else {
          player.points += 8;
        }
      })]);
    //Shop items
    this.shopItems.push([
      new ShopItem(12, player => { player.gun.smg(); }),//Up
      new ShopItem(100, player => { player.gun.assault(); }),//Right
      new ShopItem(400, player => { player.gun.shotgun(); }),//Down
      new ShopItem(1000, player => { player.gun.sniper(); }),//Left
    ]);
    this.shopItems.push([
      new ShopItem(50, player => { player.damageAdder++; }, 2.2),
      new ShopItem(130, player => { player.maxHealth += 10; player.health += 10; }, 1.5),
      new ShopItem(200, player => { player.speedMultiplier += 0.08; }, 1.9),
      new ShopItem(500, player => { player.shotMultiplier++; }, 2.8),
    ]);
    //Revive logic
    if (this.deadPlayers.length >= 1) {
      for (let i = 0; i < this.deadPlayers.length; i++) {
        this.shopItems[3][i] = new ShopItem(Math.floor(Math.pow(10, (self.level - 1) / 10 + 1)), () => {
          var currentDeadPlayer = self.deadPlayers[i];
          var newPlayerBody = new Player(self.camX + canvas.width / 2, self.camY - self.playerSize * 2, currentDeadPlayer.controller, currentDeadPlayer.number);
          newPlayerBody.kills = currentDeadPlayer.kills;
          newPlayerBody.damageDone = currentDeadPlayer.damageDone;
          newPlayerBody.points = Math.floor(currentDeadPlayer.points / 4);
          self.players.push(newPlayerBody);
          self.deadPlayers.splice(i, 1);
          self.shopItems[3].splice(i, 1);
        });
      }
    }


    function shopLogic(player, shopTrigger, upButton, downButton, leftButton, rightButton) {
      if (player.hasShop && shopTrigger) {
        player.shopOpened = true;
        if (!leftButton && !rightButton && !upButton && !downButton) {
          player.shopButtonPressed = false;
        }
        function shopButton(triggerButton, handler) {
          if (triggerButton && player.shopButtonPressed === false) {
            handler();
            player.shopButtonPressed = true;
          }
        }
        function shopLoop(index) {
          var currentShopGroup = self.shopItems[index];
          for (var i = 0; i < currentShopGroup.length; i++) {
            var shopTriggerButton;
            switch (i) {
              case 0:
                shopTriggerButton = upButton;
                break;
              case 1:
                shopTriggerButton = rightButton;
                break;
              case 2:
                shopTriggerButton = downButton;
                break;
              case 3:
                shopTriggerButton = leftButton;
                break;
            }
            shopButton(shopTriggerButton, () => { currentShopGroup[i].award(player); });
          }
        }
        if (player.shopMenu === "main") {
          shopButton(leftButton, () => { self.shopItems[0][0].award(player); });
          shopButton(upButton, () => { player.shopMenu = "revive"; });
          shopButton(rightButton, () => { player.shopMenu = "guns"; });
          shopButton(downButton, () => { player.shopMenu = "perks"; });
        }
        if (player.shopMenu === "guns") {
          shopLoop(1);
        }
        if (player.shopMenu === "guns2") {
          shopLoop(2);
        }
        if (player.shopMenu === "perks") {
          shopLoop(2);
        }
        if (player.shopMenu === "revive") {
          shopLoop(3);
        }
      } else {
        player.shopOpened = false;
        player.shopMenu = "main";
      }
    }
    //Update player logic
    let horizontalScreenEdgeDeadzone = 200;
    let verticalScreenEdgeDeadzone = canvas.height / 2 - (self.playerSize * 3);
    Player.prototype.update = function () {
      this.currentGravityForce = getTransition(self.gravityForce, 1000);
      let verticalMovementSpeed = this.currentGravityForce * 4;
      let playerMovementSpeed = this.currentGravityForce * 3 * this.speedMultiplier;
      if (!this.controller) {
        //Define control systems for internal use
        this.keyboardShop = devices.keyboard.keyCodes[88];//X
        if (!(this.keyboardShop && this.hasShop)) {
          this.keyboardUp = devices.keyboard.keyCodes[38];
          this.keyboardDown = devices.keyboard.keyCodes[40];
          this.keyboardLeft = devices.keyboard.keyCodes[37];
          this.keyboardRight = devices.keyboard.keyCodes[39];
          this.keyboardShoot = devices.keyboard.keyCodes[90];//Z
        }

        if (this.falling) {
          this.gravity += this.currentGravityForce;
        } else if (!this.keyboardUp) {
          this.gravity = 0;
        }

        //Jumping
        if (this.keyboardUp && this.jumping === false) {
          this.gravity -= this.currentGravityForce * 60;
          this.jumpKeyReleased = false;
          this.jumping = true;
        }
        if (!this.keyboardUp && this.jumping === true) {
          this.jumpKeyReleased = true;
        }
        if (this.keyboardDown) {
          this.gravity += verticalMovementSpeed;
        }
        //Horizontal
        if (this.keyboardRight) {
          this.horizontalVelocity += playerMovementSpeed;
          this.direction = 'right';
        }
        if (this.keyboardLeft) {
          this.horizontalVelocity -= playerMovementSpeed;
          this.direction = 'left';
        }

        shopLogic(this, this.keyboardShop, devices.keyboard.keyCodes[38], devices.keyboard.keyCodes[40], devices.keyboard.keyCodes[37], devices.keyboard.keyCodes[39]);
      }
      if (this.controller) {
        //Define control systems for internal use
        this.controllerShop = this.controller.buttons[4].pressed;//L1
        this.controllerUp = this.controller.buttons[0].pressed;//X
        this.controllerLeftStickY = this.controller.axes[1];//Right-down stick
        this.controllerLeftStickX = this.controller.axes[0];
        this.controllerShoot = this.controller.buttons[3].pressed;//Square

        if (this.falling) {
          this.gravity += this.currentGravityForce;
        } else if (!this.controllerUp) {
          this.gravity = 0;
        }

        //Jumping
        if (this.controllerUp && this.jumping === false) {
          this.gravity -= this.currentGravityForce * 60;
          this.jumpKeyReleased = false;
          this.jumping = true;
        }
        if (!this.controllerUp && this.jumping === true) {
          this.jumpKeyReleased = true;
        }
        if (this.controllerLeftStickY > 0.9) {
          this.gravity += verticalMovementSpeed;
        }
        //Horizontal
        if (Math.abs(this.controllerLeftStickX) > self.controllerDeadzone) {
          this.horizontalVelocity += playerMovementSpeed * this.controllerLeftStickX;
          this.direction = 'left';
          if (this.controllerLeftStickX > 0) {
            this.direction = 'right';
          }
        }

        shopLogic(this, this.controllerShop, (this.controller.axes[7] < 0), (this.controller.axes[7] > 0), (this.controller.axes[6] < 0), (this.controller.axes[6] > 0));
      }
      this.horizontalVelocity = this.horizontalVelocity / 1.06;

      //Prevent player from going off screen
      var screenDeadzone = 10;
      if (this.x - self.camX <= screenDeadzone) {
        this.x += self.camX - (this.x - screenDeadzone);
      }
      if (this.x + self.playerSize - self.camX >= canvas.width - screenDeadzone) {
        this.x += (self.camX + (canvas.width - screenDeadzone)) - (this.x + self.playerSize);
      }
      if (this.y - self.camY <= screenDeadzone) {
        this.y += self.camY - (this.y - screenDeadzone);
      }
      if (this.y + self.playerSize - self.camY >= canvas.height - screenDeadzone) {
        this.y += (self.camY + (canvas.height - screenDeadzone)) - (this.y + self.playerSize);
      }

      //Apply gravities
      this.y += this.gravity;
      this.x += this.horizontalVelocity;
    }
    Player.prototype.shoot = function () {
      //Shooting
      if (this.keyboardShoot || this.controllerShoot) {
        if (self.menuState === "game") {
          var shotDirection = 1;
          if (this.direction === 'left') {
            shotDirection = -1;
          }
          if (this.gun.special === false) {
            if (this.gun.automatic === false && this.gunFired === false) {
              for (var i = 0; i < this.shotMultiplier; i++) {
                fireBullet(this.x + self.playerSize / 2, this.y + self.playerSize / 2, shotDirection, customRandom(-this.gun.spread / 100, this.gun.spread / 100), this);
              }
              this.gunFired = true;
            }
            if (this.gun.automatic === true) {
              this.gunCooldownCounter += getAnimationExpansionRate(this.gun.fireRate, 1000);
              if (this.gunShotCount <= this.gunCooldownCounter) {
                for (var i = 0; i < this.shotMultiplier; i++) {
                  fireBullet(this.x + self.playerSize / 2, this.y + self.playerSize / 2, shotDirection, customRandom(-this.gun.spread / 100, this.gun.spread / 100), this);
                }
                this.gunShotCount++;
              }
            }
          } else {
            if (this.gun.name === "shotgun" && this.gunFired === false) {
              for (var i = 0; i < 8 + (this.shotMultiplier - 1); i++) {
                fireBullet(this.x + self.playerSize / 2, this.y + self.playerSize / 2, shotDirection, customRandom(-this.gun.spread / 100, this.gun.spread / 100), this);
              }
              this.gunFired = true;
            }
          }
        }
      } else {
        this.gunFired = false;
        this.gunCooldownCounter = 0;
        this.gunShotCount = 0;
      }
    }
    Player.prototype.moveCamera = function () {
      //Move camera when approaching the end of the screen
      if (this.x - self.camX + self.playerSize + this.horizontalVelocity > canvas.width - horizontalScreenEdgeDeadzone) {
        self.camX += (this.x - self.camX + self.playerSize) - (canvas.width - horizontalScreenEdgeDeadzone);
      }
      if (this.x - self.camX + this.horizontalVelocity < horizontalScreenEdgeDeadzone) {
        self.camX += (this.x - self.camX) - horizontalScreenEdgeDeadzone;
      }
      if (this.y - self.camY + self.playerSize + this.gravity > canvas.height - verticalScreenEdgeDeadzone) {
        self.camY += (this.y - self.camY + self.playerSize) - (canvas.height - verticalScreenEdgeDeadzone);
      }
      if (this.y - self.camY + this.gravity < verticalScreenEdgeDeadzone) {
        self.camY += (this.y - self.camY) - verticalScreenEdgeDeadzone;
      }
    }
    Player.prototype.updateWorld = function () {
      //Deal with world interaction
      var fallingVariableBuffer = true;
      var hasShopBuffer = false;
      for (var i = -1; i < Math.floor(self.playerSize / self.groundStepWidth + 2); i++) {
        let currentWorld = self.world[Math.abs(i + Math.floor(this.x / self.groundStepWidth))];
        if (currentWorld) {
          let currentWorldLevel = currentWorld[0];
          let currentWorldLevelX = Math.floor(this.x / self.groundStepWidth + i) * self.groundStepWidth;
          //Deal with collisions
          if (this.y + self.playerSize + 1 > currentWorldLevel && this.x + self.playerSize > currentWorldLevelX && this.x < currentWorldLevelX + self.groundStepWidth) {
            fallingVariableBuffer = false;
            if (this.jumpKeyReleased === true) {
              this.jumping = false;
            }
            if (self.playerSize / 5 + this.gravity > this.y + self.playerSize + 1 - currentWorldLevel) {
              this.y = currentWorldLevel - self.playerSize;
            } else {
              if (this.horizontalVelocity > 0 && this.x + self.playerSize > currentWorldLevelX) {
                this.x = currentWorldLevelX - self.playerSize - this.horizontalVelocity;
                this.horizontalVelocity = 0;
              }
              if (this.horizontalVelocity < 0 && this.x < currentWorldLevelX + self.groundStepWidth) {
                this.x = currentWorldLevelX + self.groundStepWidth - this.horizontalVelocity;
                this.horizontalVelocity = 0;
              }
            }
          }
          if (this.y > currentWorldLevel) {
            this.y = currentWorldLevel - self.playerSize;
          }
          if (currentWorld[1] === true) {
            hasShopBuffer = true;
          }
        }
      }
      this.hasShop = hasShopBuffer;
      this.falling = fallingVariableBuffer;
    }
    //Draw player
    Player.prototype.draw = function () {
      if (this.x - self.camX >= 0 && this.y - self.camY >= 0 && this.x - self.camX + self.playerSize <= canvas.width && this.y - self.camY + self.playerSize <= canvas.height) {
        graphics.save();
        stroke(0);
        fill(255, 50, 50);
        translate(this.x - self.camX, this.y - self.camY);
        rect(0, -10, this.health / this.maxHealth * self.playerSize, 5);
        fillPlayerNumber(this.number);
        rect(0, 0, self.playerSize, self.playerSize);

        if (this.shopOpened === true) {
          //Shop menu
          graphics.save();
          var shopScale = 1.3;
          translate(self.playerSize / 2, -65 * shopScale);
          scale(shopScale);
          fill(230, 230, 230);
          ellipse(0, 0, 70, 70);
          stroke(0);
          line(-20, -20, 20, 20);
          line(20, -20, -20, 20);
          textSize(10);
          var thisPlayer = this;
          var displayGun = new Gun();
          function displayPrice(price, side) {
            if (thisPlayer.points < price) {
              fill(255, 70, 70);
            } else {
              fill(0, 225, 0);
            }
            var textAlignment;
            switch (side) {
              case 'left':
                textAlignment = [-51, 5];
                break;
              case 'right':
                textAlignment = [51, 5];
                break;
              case 'bottom':
                textAlignment = [0, 47];
                break;
              case 'top':
                textAlignment = [0, -44];
                break;
            }
            simpleCenterText("$" + price, textAlignment[0], textAlignment[1]);
          }
          if (this.shopMenu === "main") {
            //Health
            //Do not stroke here;
            displayPrice(self.shopItems[0][0].cost, 'left');
            fill(255, 30, 30);
            rect(-22.5, 0, 5, 5);
            rect(-19.5, -3.5, 5, 5);
            rect(-25.5, -3.5, 5, 5);

            //Perks
            fill(10, 90, 255);
            rect(-7.5, 17, 17, 6);
            rect(-2, 12, 6, 16);

            //Gun
            graphics.save();
            translate(13, -11 / 2);
            displayGun.pistol();
            displayGun.art();
            graphics.restore();

            //Revive
            fill(70, 200, 70)
            triangle(0, -28, 8, -21, -8, -21);
            rect(-4, -23, 8, 10, 2);

          }
          function displayShopPrices(shopItemList) {
            //Do not stroke here;
            for (var i = 0; i < shopItemList.length; i++) {
              var displaySide;
              switch (i) {
                case 0:
                  displaySide = "top";
                  break;
                case 1:
                  displaySide = "right";
                  break;
                case 2:
                  displaySide = "bottom";
                  break;
                case 3:
                  displaySide = "left";
                  break;
              }
              displayPrice(shopItemList[i].cost, displaySide);
            }
          }
          if (this.shopMenu === "guns") {
            //SMG
            graphics.save();
            translate(-12, -28);
            scale(0.5);
            displayGun.smg();
            displayGun.art();
            graphics.restore();

            //Assault Rifle
            graphics.save();
            translate(11, -2);
            scale(0.48);
            displayGun.assault();
            displayGun.art();
            graphics.restore();

            //Shotgun
            graphics.save();
            translate(-10, 17);
            scale(0.4);
            displayGun.shotgun();
            displayGun.art();
            graphics.restore();

            //Sniper
            graphics.save();
            translate(-28, -1);
            scale(0.5);
            displayGun.sniper();
            displayGun.art();
            graphics.restore();

            displayShopPrices(self.shopItems[1]);
          }
          if (this.shopMenu === "perks") {
            graphics.save();
            //Bullet damage
            scale(0.5);
            //Do not stroke here;
            graphics.save();
            translate(-18, -50);
            fill(125, 125, 125);
            rect(12,0,11,10,10);
            rect(0,0,18,10,1);

            fill(255, 64, 64);
            var xOffset = 23;
            var yOffset = 1;
            rect(-5.5 + xOffset, 17 + yOffset, 17, 6);
            rect(0 + xOffset, 12 + yOffset, 6, 16);
            graphics.restore();

            //More max health
            graphics.save();
            translate(35, 0);
            scale(2);
            //Do not stroke here;
            fill(255, 200, 40);
            rect(0, 0, 5, 5);
            rect(3, -3.5, 5, 5);
            rect(-3, -3.5, 5, 5);
            graphics.restore();

            //Speed
            graphics.save();
            translate(-14, 30);
            scale(0.7);
            fill(40, 220, 225);
            stroke(0);

            beginShape();
            vertex(0,-5);
            vertex(20,-5);
            vertex(16,-15);
            vertex(34,0);
            vertex(16,15);
            vertex(20,5);
            vertex(0,5);
            vertex(0,-5);
            endShape();

            translate(17,26);
            
            beginShape();
            vertex(0,-5);
            vertex(20,-5);
            vertex(16,-15);
            vertex(34,0);
            vertex(16,15);
            vertex(20,5);
            vertex(0,5);
            vertex(0,-5);
            endShape();
            graphics.restore();

            //More Bullets
            graphics.save();
            translate(-60, -13);
            fill(125, 125, 125);
            rect(12,0,11,10,10);
            rect(0,0,18,10,1);

            rect(21,17,11,10,10);
            rect(9,17,18,10,1);
            graphics.restore();

            graphics.restore();

            displayShopPrices(self.shopItems[2]);
          }
          if (this.shopMenu === "revive") {
            for (var i = 0; i < self.deadPlayers.length; i++) {
              graphics.save();
              switch (i) {
                case 0:
                  displayPrice(self.shopItems[3][i].cost, 'top');
                  translate(0, -20);
                  break;
                case 1:
                  displayPrice(self.shopItems[3][i].cost, 'right');
                  translate(20, 0);
                  break;
                case 2:
                  displayPrice(self.shopItems[3][i].cost, 'bottom');
                  translate(0, 20);
                  break;
                case 3:
                  displayPrice(self.shopItems[3][i].cost, 'left');
                  translate(-20, 0);
                  break;
              }
              fillPlayerNumber(self.deadPlayers[i].number);
              rect(-8, -8, 16, 16);
              graphics.restore();
            }
          }
          graphics.restore();
        } else if (this.hasShop === true) {
          //Shop hint
          fill(255);
          //Do not stroke here;
          textSize(16);
          if (this.controller) {
            simpleCenterText("Hold L1 to open the shop", self.playerSize / 2, -20);
          } else {
            simpleCenterText("Hold X to open the shop", self.playerSize / 2, -20);
          }
        }

        this.gun.art(this.direction);
        graphics.restore();
      }
    }
    //Enemies
    function Enemy(enemy) {
      if (enemy !== undefined) {
        this.x = enemy.x + customRandom(-self.enemySize * 2, self.enemySize * 2);
        this.y = enemy.y - 2;
        this.gravity = enemy.gravity;
        this.horizontalVelocity = enemy.horizontalVelocity;
      } else {
        this.x = self.camX + Math.random() * canvas.width;
        this.y = -self.enemySize + self.camY;
        this.gravity = 0;
        this.horizontalVelocity = 0;
      }

      this.health = 100;

      this.falling = true;
      this.geneticVariation = Math.random() + 0.5;
    }
    //Update enemy world interaction logic
    Enemy.prototype.updateWorld = function () {
      //Deal with ground collision and jumping
      var fallingVariableBuffer = true;
      var verticalMovementSpeed = self.enemySize / 5;
      for (var i = -1; i < Math.floor(self.enemySize / self.groundStepWidth + 2); i++) {
        let currentWorld = self.world[Math.abs(i + Math.floor(this.x / self.groundStepWidth))];
        if (currentWorld) {
          let currentWorldLevel = currentWorld[0];
          let currentWorldLevelX = Math.floor(this.x / self.groundStepWidth + i) * self.groundStepWidth;
          //Deal with collisions
          if (this.y + self.enemySize + 1 > currentWorldLevel && (this.x + self.enemySize) > currentWorldLevelX && (this.x) < currentWorldLevelX + self.groundStepWidth) {
            fallingVariableBuffer = false;
            if ((this.y + self.enemySize + 1 - currentWorldLevel) < self.enemySize / 5 + this.gravity) {
              this.y = currentWorldLevel - self.enemySize;
            } else {
              if (this.horizontalVelocity > 0 && this.x + self.enemySize > currentWorldLevelX) {
                this.x = currentWorldLevelX - self.enemySize;
                this.horizontalVelocity = 0;
                this.gravity -= verticalMovementSpeed * this.geneticVariation;
                this.jumping = true;
              }
              if (this.horizontalVelocity < 0 && this.x < currentWorldLevelX + self.groundStepWidth) {
                this.x = currentWorldLevelX + self.groundStepWidth;
                this.horizontalVelocity = 0;
                this.gravity -= verticalMovementSpeed * this.geneticVariation;
                this.jumping = true;
              }
            }
          }
        } else {
          this.suspend = true;
        }
      }
      this.falling = fallingVariableBuffer;
    }
    //Update enemy logic
    Enemy.prototype.update = function () {
      var enemyMovementSpeed = getTransition((100 / Math.max(5, this.health)) + (self.gravityForce * 1.2 + (this.geneticVariation * 3 - 1.5)), 1000);
      if (this.suspend === false) {
        let currentGravityForce = getTransition(self.gravityForce, 1000);
        if (this.falling) {
          this.gravity += currentGravityForce;
        } else if (!this.jumping) {
          this.gravity = 0;
        }
        this.jumping = false;

        //Find nearest player to target
        var leastPlayerDistance = Infinity;
        let targetPlayer;
        for (var i = 0; i < self.players.length; i++) {
          var currentPlayer = self.players[i];
          var playerDistance = Math.abs(this.x - currentPlayer.x) + Math.abs(this.y - currentPlayer.y);
          if (playerDistance < leastPlayerDistance) {
            leastPlayerDistance = playerDistance;
            targetPlayer = currentPlayer;
          }
        }
        if (!targetPlayer) {
          targetPlayer = new Player(this.x, 0);
        }

        //Horizontal
        if (this.x < targetPlayer.x + self.playerSize / 2 - self.enemySize / 2) {
          this.horizontalVelocity += enemyMovementSpeed;
        } else {
          this.horizontalVelocity -= enemyMovementSpeed;
        }
        this.horizontalVelocity = this.horizontalVelocity / 1.06;

        //Apply gravities
        this.y += this.gravity;
        this.x += this.horizontalVelocity;
      }
      this.suspend = false;
    }
    Enemy.prototype.draw = function () {
      if (this.x - self.camX > 0 && this.y - self.camY > 0 && this.x - self.camX + self.enemySize < canvas.width && this.y - self.camY + self.enemySize < canvas.height) {
        fill(255, (this.health / 100) * 130, (this.health / 100) * 130);
        rect(this.x - self.camX, this.y - self.camY, self.enemySize, self.enemySize);
      }
    }
    self.world[0] = [canvas.height / 2, false, false];

    //Menu system
    if (this.menuState === "start") {
      fill(150, 205, 150);
      rect(0, 0, canvas.width, canvas.height);

      fill(0);
      centerText("SOTF", canvas.width / 2 - 20, canvas.height / 2 - 20, 40, 40, 75);
      this.startupScreenTimer -= getAnimationExpansionRate(72, 2500);
      if (this.startupScreenTimer <= 0) {
        this.menuState = "menu";
      }
    }
    if (this.menuState === "menu") {
      fill(127);
      rect(0, 0, canvas.width, canvas.height);
      fill(255);
      centerText("Survival of the Fittest", canvas.width / 2 - 20, 30, 40, 40, 75);

      //Start Game button
      function singlePlayerMenuState() {
        self.menuState = "game";
        resumeSystem(self.logicProcesses, true);
        self.players.push(new Player(canvas.width / 2, 60));
        self.enemies.push(new Enemy());
      }
      function multiplayerMenuState() {
        self.menuState = "multiplayer";
      }
      fill(30);
      labledButton(100, 150, canvas.width - 200, 100, singlePlayerMenuState, "Single Player", 30);
      fill(30);
      labledButton(100, 300, canvas.width - 200, 100, multiplayerMenuState, "Multiplayer", 30);
    }
    if (this.menuState === "multiplayer") {
      fill(127);
      rect(0, 0, canvas.width, canvas.height);
      fill(255);
      centerText("To join, press X on your controller.", canvas.width / 2 - 20, 50, 40, 40, 32);
      function startMultiplayerGame() {
        self.players = self.playerBuffer;
        self.menuState = "game";
        resumeSystem(self.logicProcesses, true);
        for (var i = 0; i < self.playerBuffer.length; i++) {
          self.enemies.push(new Enemy());
        }
        self.levelKillGoal = self.levelKillGoal * self.playerBuffer.length;
        self.playerBuffer = [];
      }
      if (this.playerBuffer.length > 0) {
        labledButton(100, 400, canvas.width - 200, 40, startMultiplayerGame, "All players are ready", 20);
      }
      for (var i = 0; i < controllerArray.length; i++) {
        if (controllerArray[i].buttons[0].pressed) {
          var controllerHasPlayer = false;
          for (var l = 0; l < this.playerBuffer.length; l++) {
            if (controllerArray[i].index === this.playerBuffer[l].controller.index) {
              controllerHasPlayer = true;
            }
          }
          if (controllerHasPlayer === false) {
            this.playerBuffer.push(new Player(canvas.width / 2, 60, controllerArray[i], this.playerBuffer.length));
          }
        }
        if (controllerArray[i].buttons[1].pressed) {
          for (var l = 0; l < this.playerBuffer.length; l++) {
            if (controllerArray[i].index === this.playerBuffer[l].controller.index) {
              this.playerBuffer.splice(l, 1);
              for (var x = 0; x < this.playerBuffer.length; x++) {
                this.playerBuffer[x].number = x;
              }
            }
          }
        }
      }
      for (let i = 0; i < this.playerBuffer.length; i++) {
        graphics.save();
        fillPlayerNumber(this.playerBuffer[i].number);
        if (this.playerBuffer[i].controller.buttons[0].pressed) {
          fill(255);
        }
        rect(200 + (canvas.width - 200) * (i / this.playerBuffer.length), 200, self.playerSize, self.playerSize);
        blankButton(200 + (canvas.width - 200) * (i / this.playerBuffer.length), 200, self.playerSize, self.playerSize, () => {
          self.playerBuffer.splice(i, 1);
        });
        graphics.restore();
      }
    }

    if (this.transitionNextLevel === true) {
      this.nextLevelTransitionCounter += getAnimationExpansionRate(1, 1000);
      var timeLeft = (3 - floor(this.nextLevelTransitionCounter));
      if (timeLeft <= 0) {
        this.levelKillGoal = Math.round(this.levelKillGoal * 1.5);
        this.enemiesKilled = 0;
        this.level++;
        for (var i = 0; i < this.level * this.players.length; i++) {
          this.enemies.push(new Enemy());
        }
        this.levelFinished = false;
        this.transitionNextLevel = false;
        this.nextLevelTransitionCounter = 0;
      } else {
        graphics.save();
        fill(50, 155, 50);
        centerText("Level Complete!", canvas.width / 2 - 40, 100, 40, 40, 20);
        fill(35);
        textSize(18)
        text("Next level beginning in " + timeLeft + " seconds...", 100, 100);
        graphics.restore();
      }
    }

    if (this.menuState === "no players") {
      //Start Game button
      function revertMenuState() {
        self.menuState = "menu";
        self.world = [];
        self.enemies = [];
        self.players = [];
        self.deadPlayers = [];
        self.level = 1;
        self.camX = 0;
        self.camY = 0;
        self.levelKillGoal = 2;
        self.enemiesKilled = 0;
        for (var i = 0; i < self.shopItems.length; i++) {
          for (var l = 0; l < self.shopItems[i].length; l++) {
            self.shopItems[i][l].resetPrice();
          }
        }
        suspendSystem(self.logicProcesses, true);
      }
      graphics.save();
      fill(255, 0, 0);
      centerText("Loser Cruiser", canvas.width / 2 - 20, 100, 40, 40, 40);

      fill(30);
      Button(canvas.width / 2 - 150, canvas.height / 2 - 100, 300, 200, revertMenuState);
      fill(255)
      centerText("Main Menu", canvas.width / 2 - 20, canvas.height / 2 - 20, 40, 40, 20);
      graphics.restore();
    }
  }
  updateGameProcesses() {
    if (this.menuState === "game") {
      updateProcesses(this.processes);
    }
  }
  updateLogic() {
    if (this.enemiesKilled >= Math.round(this.levelKillGoal) && this.menuState === "game" && this.transitionNextLevel === false) {
      this.transitionNextLevel = true;
      this.enemies = [];
      for (var i = 0; i < this.players.length; i++) {
        this.players[i].health += 15;
        if (this.players[i].health > this.players[i].maxHealth) {
          this.players[i].health = this.players[i].maxHealth;
        }
        this.players[i].points += this.level;
      }
    }
    if (this.players.length === 0) {
      this.menuState = "no players";
    }
  }
  createWindow(mode) {
    var self = new SOTF();
    //Functions for updating game mechanics
    function drawPlayers() {
      graphics.save();
      for (var i = self.players.length - 1; i >= 0; i--) {
        self.players[i].moveCamera();
        self.players[i].draw();
      }
      graphics.restore();
    }
    function updatePlayers() {
      for (var i = 0; i < self.players.length; i++) {
        self.players[i].updateWorld();
        self.players[i].update();
      }
    }
    function updatePlayerShooting() {
      for (var i = 0; i < self.players.length; i++) {
        self.players[i].shoot();
      }
    }
    function drawEnemies() {
      graphics.save();
      stroke(0);
      for (var i in self.enemies) {
        self.enemies[i].draw();
      }
      graphics.restore();
    }
    function updateEnemies() {
      for (var i = 0; i < self.enemies.length; i++) {
        self.enemies[i].updateWorld();
        self.enemies[i].update();
        if (self.enemies.dead === true) {
          self.enemies.splice(i, 1);
        }
      }
    }
    function updateEnemyPlayerCollisions() {
      for (var i = 0; i < self.players.length; i++) {
        var currentPlayer = self.players[i];
        for (var l = 0; l < self.enemies.length; l++) {
          var currentEnemy = self.enemies[l];
          if (currentEnemy.x + self.enemySize > currentPlayer.x && currentEnemy.x < currentPlayer.x + self.playerSize && currentEnemy.y + self.playerSize > currentPlayer.y && currentEnemy.y < currentPlayer.y + self.playerSize) {
            currentPlayer.health -= getTransition(100, 5000);
          }
        }
        if (currentPlayer.health < 0) {
          self.deadPlayers.push(self.players[i]);
          self.players.splice(i, 1);
        }
      }
    }
    function capEnemyCount() {
      if (self.enemies.length > self.levelKillGoal - self.enemiesKilled && self.enemies.length > 0) {
        for (var i = self.enemies.length; i >= Math.min(self.levelKillGoal - self.enemiesKilled, 1000); i--) {
          self.enemies.splice(i, 1);
        }
      }
    }
    //World Generation
    function generateWorld() {
      var newGenerationHeight;
      var generationOverscan = (60 / self.groundStepWidth);
      for (var i = 1; i < canvas.width / self.groundStepWidth + generationOverscan * 2; i++) {
        var worldIndex = Math.abs(i + Math.floor(self.camX / self.groundStepWidth - generationOverscan));
        if (!self.world[worldIndex]) {
          if (worldIndex !== 0) {
            let previousWorld = self.world[worldIndex - 1];
            for (var l = 1; previousWorld === undefined; l++) {
              previousWorld = self.world[worldIndex - l];
            }
            if (self.worldGenerationNumber > 0) {
              self.worldGenerationNumber = Math.min(self.groundStepHeight * 15, self.worldGenerationNumber + customRandom(-self.groundStepHeight, self.groundStepHeight));
            } else {
              self.worldGenerationNumber = Math.max(-(self.groundStepHeight * 15), self.worldGenerationNumber + customRandom(-self.groundStepHeight, self.groundStepHeight));
            }
            newGenerationHeight = previousWorld[0] + self.worldGenerationNumber;
          }
          //World Features: [y, hasShop, hasFlower]
          self.world[worldIndex] = [newGenerationHeight, (Math.random() < 0.005), (Math.random() < 0.08)];
        }
      }
    }
    function renderWorld() {
      graphics.save();
      //Do not stroke here;
      fill(100, 255, 100);
      var adjustedCamX = self.camX / self.groundStepWidth;
      for (var i = Math.floor(adjustedCamX); i < canvas.width / self.groundStepWidth + adjustedCamX; i++) {
        let worldBlock = self.world[Math.abs(i)];
        if (worldBlock) {
          translate(i * self.groundStepWidth - self.camX, worldBlock[0] - self.camY);
          rect(0, 0, self.groundStepWidth, Math.max(canvas.height - (worldBlock[0] - self.camY), 0));
          if (worldBlock[2] === true) {
            fill(100, 255, 100);
            rect(self.groundStepWidth / 2 - 1, -3, 2, 3);
            fill(255, 0, 240);
            rect(self.groundStepWidth / 2 - 2.5, -8, 5, 5);
            fill(100, 255, 100);
          }
          if (worldBlock[1] === true) {
            graphics.save();
            scale(0.5);
            translate(0, -148);
            fill(210, 40, 40);
            triangle(0, 69, 0, 0, 81, 69);
            fill(220);
            rect(0, 68, 80, 80);
            fill(50, 50, 255)
            rect(54, 72, 20, 20);
            rect(5, 72, 20, 20);
            rect(5, 37, 20, 20);
            rect(25, 102, 30, 46);
            fill(127, 127, 127);
            ellipse(50, 122, 5, 5);
            graphics.restore();
          }
          translate(-(i * self.groundStepWidth - self.camX), -(worldBlock[0] - self.camY));
        }
      }
      graphics.restore();
    }
    function renderHud() {
      graphics.save();
      var hudScale = 1.5;
      graphics.scale(hudScale);
      fill(100);
      rect(canvas.width / 2, 0, canvas.width / 2, 20);

      fill(255);
      textSize(12);
      text("Level: " + self.level, canvas.width / 2 + 6, 14);
      text("Enemies Left: " + Math.max(self.levelKillGoal - self.enemiesKilled, 0), canvas.width / 2 + 70, 14);

      //Scoreboard
      //Do not stroke here;
      for (var i = 0; i < self.players.length; i++) {
        var currentPlayer = self.players[i];
        fillPlayerNumber(currentPlayer.number);
        rect(canvas.width - 200, 20 * i, 200, 20);
        fill(0);
        var killMessage = currentPlayer.kills + " kills | ";
        if (currentPlayer.kills === 1) {
          killMessage = currentPlayer.kills + " kill | ";
        }
        text("$" + currentPlayer.points + " | " + killMessage + currentPlayer.damageDone + " damage", canvas.width - 195, 14 + (20 * i));
      }
      graphics.restore();
    }
    function updateGameLogic() {
      self.updateLogic();
    }
    function drawBackground() {
      //Sky
      var resolutionScale = 30;
      //Do not stroke here;
      for (var i = 0; i < canvas.height; i += resolutionScale) {
        var scaledBackground = i * (255 / canvas.height);
        fill(100 + scaledBackground, 150, 255 - scaledBackground / 4);
        rect(0, i, canvas.width, resolutionScale + 1);
      }
      //Clouds

      /* Emo black background
      fill(0, 0, 0);
      rect(0, 0, canvas.width, canvas.height);
      */
    }
    function updateGame() {
      self.update();
    }
    //Processes
    let logicProcesses = [
      //World
      new Process(generateWorld, 0),
      //Enemies
      new Process(capEnemyCount, 2),
      new Process(updateEnemies, 1, self.logicProcesses),
      //Players
      new Process(updatePlayers, 4, self.logicProcesses),
      //Update player-enemy collissions
      new Process(updateEnemyPlayerCollisions, 0, self.logicProcesses),
      //Game logic (levels)
      new Process(updateGameLogic, 2, self.logicProcesses),
    ]
    let logicProcessesPIDs = [];
    for(let i = 0; i < logicProcesses.length; i++){
      let logicProcess = new Process(logicProcesses[i].command, logicProcesses[i].priority);
      logicProcess.name = logicProcesses[i].name;
      logicProcessesPIDs.push(logicProcess.PID);
      processes.push(logicProcess);
    }

    //Create processes to pass into the window manager
    let windowProcesses = [
      new Process(drawBackground, 1),
      new Process(renderWorld, 0),
      new Process(drawEnemies, -3),
      new Process(updatePlayerShooting, 2),
      new Process(drawPlayers, 2),
      new Process(renderHud, 1),
      new Process(updateGame, 3),
    ]

    if (mode === "fullscreen") {
      var sotfWindow = new GraphiteWindow("Survival of the Fittest", windowProcesses, false, self.logicProcesses);
      sotfWindow.x = canvas.width / 2;
      sotfWindow.y = canvas.height / 2;
      sotfWindow.targetWidth = canvas.width;
      sotfWindow.targetHeight = canvas.height;
      windows.push(sotfWindow);
    } else if(mode === "standalone"){
      for(let i = 0; i < windowProcesses.length; i++){
        graphicalProcesses.push(windowProcesses[i]);
      }
      addProcessGroup(self.logicProcesses);
    }else {
      //Add game processes to the window manager
      var sotfWindow = new GraphiteWindow(windowProcesses, "Survival of the Fittest");
      sotfWindow.maximize = true;
      sotfWindow.initProcesses();
      windows.push(sotfWindow);
    }
    suspendSystem(self.logicProcesses, true);
  }
  iconFunction(canvas, graphics) {
    graphics.fillStyle = "#50c850";
    graphics.fillRect(0, 0, canvas.width, canvas.height, 3);
    graphics.fillStyle = "white";
    graphics.font = (canvas.width / 5) + "pt Arial";
    graphics.fillText("SOTF", canvas.width / 10, canvas.height / 2.5);
    graphics.fillRect(canvas.width / 10, canvas.height * 0.7, canvas.width * 0.8, canvas.height / 5);
  }
}class CookieClicker{
    constructor(){
        this.money = 0;
        this.shops = [];
        this.clickPower = 1;
        this.cps = 0;
        this.spacebarPressed = false;

        let self = this;
        function Shop (price, cps, title, customFunction) {
            this.price = price;
            this.cps = cps;
            this.title = title;
            this.custom = (customFunction !== undefined);
            this.customFunction = customFunction;
        }
        function createShop (cps, title) {
            self.shops.push(new Shop(Math.pow(cps, 0.9) * 100, cps, title));
        }
        //Create shops
        let powerClickShop = new Shop(10, 0, "Power Click", () => {});
        powerClickShop.customFunction = () => {
            powerClickShop.price = powerClickShop.price * 20;
            this.clickPower *= 2;
        }
        self.shops.push(powerClickShop);
        createShop(0.1, "Slave");
        createShop(1, "Granny");
        createShop(5, "Farmer");
        createShop(20, "Plantation");
        createShop(100, "Factory");
        createShop(500, "Shipment");
        createShop(1000, "Rocket");
        createShop(10000, "Wormhole");
        createShop(50000, "Multiverse");
        createShop(100000, "Dimension");
    }
    update(canvas, graphics){
        //Background
        graphics.strokeStyle = "";
        graphics.fillStyle = "white";
        graphics.fillRect(0, 0, canvas.width, canvas.height);

        //Draw shops
        for(var i = 0; i < this.shops.length; i++){
            let currentButton = this.shops[i];
            labledButton(graphics, 5, 5 + i*35, canvas.width/2, 30, () => {
                if(this.money >= currentButton.price){
                    this.money -= currentButton.price;
                    if(currentButton.custom !== true){
                        this.cps += currentButton.cps;
                        currentButton.price = currentButton.price * 1.2;
                    }else{
                        currentButton.customFunction();
                    }
                }
            }, currentButton.title + "- " + currentButton.cps + " CPS, $" + Math.round(currentButton.price));
        }

        //Draw cookie
        graphics.fillStyle = "#005096";
        graphics.ellipse(canvas.width/4 + canvas.width/2, canvas.height/2, canvas.height/3, canvas.height/3, 0, 0, 0, false);
        if(devices.mouse.pressed && this.keyPressed === false){
            this.money += this.clickPower;
            this.keyPressed = true;
        }
        if(!devices.mouse.pressed){
            this.keyPressed = false;
        }
        blankButton(canvas.width/4 + canvas.width/2 - canvas.height/6, canvas.height/2 - canvas.height/6, canvas.height/3, canvas.height/3, () => {this.money += this.clickPower});

        //Draw money
        graphics.fillStyle = "black";
        centerText(graphics, "$" + Math.floor(this.money), canvas.width/4 + canvas.width/2, 30, 0, 0, 30);
        centerText(graphics, "CPS: " + (Math.floor(this.cps*10)/10), canvas.width/4 + canvas.width/2, canvas.height - 30, 0, 0, 20);

        this.money += getTransition(this.cps, 1000);
    }
    createWindow(){
        var self = new CookieClicker();
        quickWindow((canvas, graphics) => {self.update(canvas, graphics)}, "Cookie Clicker");
    }
    iconFunction(canvas, graphics){
        graphics.fillStyle = "#964b00";
        graphics.fillRect(0, 0, canvas.width, canvas.height, 10);
        graphics.fillStyle = "#965a0a";
        graphics.ellipse(100, 100, 50, 75, Math.PI / 4, 0, 2 * Math.PI);
        graphics.ellipse(canvas.width/2, canvas.height/2, Math.max(canvas.width - 15, 0), Math.max(canvas.height - 15, 0), 0, 2 * Math.PI, 0);
    }
}class Autoclick{
    constructor(){
        this.clicked = false;
        this.clicking = false;
    }
    update(canvas, graphics){
        graphics.fillStyle = "gray"
        graphics.fillRect(0,0,canvas.width, canvas.height);
        this.clicking = booleanToggleButton(graphics, this.clicking, "Start autoclicker", "Stop autoclicker", 20, 20, canvas.width-40, canvas.height-40, () => {
            setTimeout(() => {
                if(this.clicking){
                    this.startClicking = true;
                }else{
                    this.startClicking = false;
                }
            }, 1000);
        });
        
        if(this.clicking && this.startClicking){
            if(this.clicked === false){
                devices.mouse.clicked = true;
                this.clicked = true;
                return;
            }
            if(this.clicked === true){
                devices.mouse.clicked = false;
                this.clicked = false;
                return;
            }
        }
    }
    createWindow(){
        let autoclick = new Autoclick();
        quickWindow((canvas, graphics) =>{autoclick.update(canvas, graphics)}, "Autoclicker");
    }
    iconFunction(canvas, graphics) {
        graphics.fillStyle = "#8888FF"
        graphics.fillRect(0,0,canvas.width, canvas.height);

        graphics.translate(35, 30);
        graphics.scale(3,3);
        //The mouse
        graphics.strokeStyle = 'white';
        graphics.fillStyle = 'black';
        graphics.lineWidth = 1;
        graphics.beginPath();
        //Base (left)
        graphics.moveTo(0, 0);
        graphics.lineTo(0, 13);
        //Handle (left)
        graphics.lineTo(3, 10);
        //Handle base (l/r)
        graphics.lineTo(5, 15);
        graphics.lineTo(8, 14);
        //Handle (right)
        graphics.lineTo(6, 9);
        //Base (right)
        graphics.lineTo(10, 9);
        graphics.lineTo(0, 0);
    
        graphics.fill();
        graphics.stroke();
    }
}class TTY {
  constructor() {

    this.prompt = "[jsterm]$ ";
    this.textArray = [];
    this.promptArray = [];
    this.textLine = 0;
    this.textBuffer = [];
    this.keyPressed = false;
    this.textOrder = 0;
  }
  update(){
    //Commandline functions
    var self = this;
    function clr() {
      self.textArray = [];
    }
    function printout(obj) {
      if (obj[0]) {
        for (var i in obj) {
          self.textArray.push(obj[i]);
        }
      } else {
        self.textArray.push(obj);
      }
    }
    if (devices.keyboard.keyCodes[13] && !this.keyPressed) {
      this.textArray.push(this.textBuffer);
      this.promptArray[this.textArray.length - 1] = this.prompt;
      if (this.textBuffer) {
        try {
          var stringToCommand = eval(this.textBuffer);
          if (stringToCommand !== undefined) {
            stringToCommandToString = stringToCommand.toString();
            for(var i = 0; i < stringToCommandToString.length; i++){
              this.textArray.push(stringToCommandToString.replace(/[^\x20-\x7E]/gmi, ""));
            }
          }
        } catch (error) {
          this.textArray.push(error);
        }
      }
      this.textBuffer = "";
      this.keyPressed = true;
      return;
    } else {
      if (devices.keyboard.keyCodes[8] && !this.keyPressed) {
        this.textBuffer = this.textBuffer.slice(0, -1);
        this.keyPressed = true;
      }
      if (devices.keyboard.keyCodes[38] && !this.keyPressed && this.textArray[this.textArray.length - (this.textOrder + 1)] !== undefined) {
        this.textOrder++;
        this.textBuffer = this.textArray[this.textArray.length - this.textOrder];
        this.keyPressed = true;
      }
      if (devices.keyboard.keyCodes[40] && !this.keyPressed && this.textArray[this.textArray.length - (this.textOrder - 1)] !== undefined) {
        this.textOrder--;
        this.textBuffer = this.textArray[this.textArray.length - this.textOrder];
        if (this.textBuffer === undefined) {
          this.textOrder = 0;
        }
        this.keyPressed = true;
      }
      if (devices.keyboard.info.keyCode !== 40 && !this.keyPressed) {
        if (devices.keyboard.info.keyCode !== 38) {
          this.textOrder = 0;
        }
      }
      if (!devices.keyboard.info.keyIsPressed) {
        this.keyPressed = false;
      }
      for (var i in devices.keyboard.keys) {
        var currentKey = devices.keyboard.keys[i]
        if (currentKey !== "Enter" && currentKey !== "Backspace" && currentKey !== "ArrowUp" && currentKey !== "ArrowDown" && currentKey !== "Alt" && currentKey !== "Shift" && currentKey !== "Tab" && currentKey !== "Control") {
          this.textBuffer += currentKey;
        }
      }
    }
  }
  draw(canvas, graphics){
    graphics.fillStyle = 'black';
    graphics.fillRect(0, 0, canvas.width, canvas.height);
    graphics.font = '12px Monospace';
    graphics.fillStyle = 'white';
    for (var i in this.textArray) {
      let currentPrompt = this.promptArray[i];
      if (currentPrompt === undefined) {
        currentPrompt = "";
      }
      graphics.fillText(currentPrompt + this.textArray[i], 2, i * 12 + 12)
    }
    graphics.fillText(this.prompt + this.textBuffer, 2, this.textArray.length * 12 + 12)
  }
  createWindow(){
    var windowProcesses = [];
    var tty = new TTY();
  
    createWindow([
      new Process(() => {tty.update();}),
      new Process((canvas, graphics) => {tty.draw(canvas, graphics);})
    ], "Terminal");
  }
  iconFunction(canvas, graphics){
    graphics.fillStyle = 'black';
    graphics.fillRect(0, 0, canvas.width, canvas.height, 10);
    graphics.fillStyle = 'white';
    graphics.font = ((canvas.width + canvas.height) / 4) + "px Monospace";
    graphics.fillText(">_", 5, canvas.height / 2);
  }
}
try{
  if(stress){
    var ttySystem = new TTY;
    function updateTTY() {
      ttySystem.update();
    }
    function drawTTY() {
      ttySystem.draw(canvas, graphics);
    }
    createProcess(updateTTY, 0);
    createProcess(drawTTY);
  }
} catch(error){}//Option variables
let cheapGraphics = false;
let cheapRender = false;
let dynamicTripleBuffering = false;
let monitorRefreshRate = 60;

//Buffering
const useBuffering = true;
let firstFrameBuffer, firstFrameBufferGraphics;
let secondFrameBuffer, secondFrameBufferGraphics;
if(useBuffering === true){
    firstFrameBuffer = document.createElement("canvas");
    firstFrameBuffer.width = canvas.width;
    firstFrameBuffer.height = canvas.height;
    firstFrameBuffer.visible = false;
    secondFrameBuffer = document.createElement("canvas");
    secondFrameBuffer.width = canvas.width;
    secondFrameBuffer.height = canvas.height;
    secondFrameBuffer.visible = false;

    firstFrameBufferGraphics = firstFrameBuffer.getContext("2d");
    secondFrameBufferGraphics = secondFrameBuffer.getContext("2d");
} else {
    firstFrameBuffer = canvas;
    firstFrameBufferGraphics = graphics;
}

let windows = [];
const windowButtonPadding = 8;
const windowMoveAnimationScale = 8;
class GraphiteWindow {
    constructor(windowProcesses, name) {
        this.x = canvas.width / 2;
        this.y = canvas.height / 2;
        this.width = 400;
        this.height = 400;
        this.topBarHeight = 40;
        this.focusable = true;
        this.virtual = false;

        this.dragged = false;
        this.processes = [];
        this.processesBuffer = windowProcesses;
        this.originalProcesses = windowProcesses;
        this.canvas = document.createElement("canvas");
        if(cheapRender === true){
            this.graphics = firstFrameBuffer.getContext('2d');
        }else{
            this.graphics = this.canvas.getContext('2d');
        }
        this.canvas.width = this.width;
        this.canvas.height = this.height;

        this.fadeFill = 0;
        this.shadowLength = 10;

        this.windowName = "window";
        if (name !== undefined) {
            this.windowName = name;
        }
    }
    close() {
        this.dying = true;
    }
    topBar(positionX, positionY) {
        if (this.topBarHeight > 0) {
            firstFrameBufferGraphics.translate(positionX, positionY);
            firstFrameBufferGraphics.fillStyle = "#222222";
            firstFrameBufferGraphics.fillRect(0, -this.topBarHeight + 1, this.width, this.topBarHeight);

            firstFrameBufferGraphics.fillStyle = "white";
            firstFrameBufferGraphics.font = "12px Monospace";
            // firstFrameBufferGraphics.fillText(this.windowName, this.width/2, this.height/2);
            firstFrameBufferGraphics.fillText(this.windowName, this.width/2 - (graphics.measureText(this.windowName).width / 2), (12 / 3) - this.topBarHeight/2);
            //Close button
            firstFrameBufferGraphics.fillStyle = "red";
            firstFrameBufferGraphics.fillRect(this.width - windowButtonPadding - (this.topBarHeight - windowButtonPadding * 2),
                windowButtonPadding - (this.topBarHeight - 1),
                this.topBarHeight - windowButtonPadding * 2,
                this.topBarHeight - windowButtonPadding * 2);
            firstFrameBufferGraphics.resetTransform();
        }
    }
    drawDecor(positionX, positionY) {
        firstFrameBufferGraphics.save();

        firstFrameBufferGraphics.translate(positionX, positionY - this.topBarHeight + 1);
        firstFrameBufferGraphics.lineWidth = this.shadowLength * 2;
        let pointsMultiplier = this.shadowLength;
        function createShadowPattern(x1, y1, x2, y2, reverse) {
            let gradient = firstFrameBufferGraphics.createLinearGradient(x1 *  pointsMultiplier, y1 * pointsMultiplier, x2 * pointsMultiplier, y2 * pointsMultiplier);
            if(reverse === true){
                gradient.addColorStop(0, "rgba(0, 0, 0, 0)");
                gradient.addColorStop(1, "rgba(0, 0, 0, 0.2)");
            }
            if(reverse === false){
                gradient.addColorStop(0, "rgba(0, 0, 0, 0.2)");
                gradient.addColorStop(1, "rgba(0, 0, 0, 0)");
            }
            firstFrameBufferGraphics.strokeStyle = gradient;
        }

        const windowBottom = this.height + (this.topBarHeight - 1);
        firstFrameBufferGraphics.translate(0, -this.shadowLength);
        createShadowPattern(0, 1, 0, 0, false);
        firstFrameBufferGraphics.beginPath();
        firstFrameBufferGraphics.lineTo(0, 0);
        firstFrameBufferGraphics.lineTo(this.width, 0);
        firstFrameBufferGraphics.fill();
        firstFrameBufferGraphics.translate(0, this.shadowLength);

        firstFrameBufferGraphics.translate(this.shadowLength, 0);
        createShadowPattern(0, 0, 1, 0, false);
        firstFrameBufferGraphics.beginPath();
        firstFrameBufferGraphics.lineTo(this.width, 0);
        firstFrameBufferGraphics.lineTo(this.width, windowBottom);
        firstFrameBufferGraphics.fill();
        firstFrameBufferGraphics.translate(-this.shadowLength, 0);

        firstFrameBufferGraphics.translate(0, this.shadowLength);
        createShadowPattern(0, 1, 0, 0, true);
        firstFrameBufferGraphics.beginPath();
        firstFrameBufferGraphics.lineTo(this.width, windowBottom);
        firstFrameBufferGraphics.lineTo(0, this.height);
        firstFrameBufferGraphics.fill();
        firstFrameBufferGraphics.translate(0, -this.shadowLength);

        firstFrameBufferGraphics.translate(-this.shadowLength, 0);
        createShadowPattern(1, 0, 0, 0, false);
        firstFrameBufferGraphics.beginPath();
        firstFrameBufferGraphics.lineTo(0, windowBottom);
        firstFrameBufferGraphics.lineTo(0, 0);
        firstFrameBufferGraphics.fill(); 

        firstFrameBufferGraphics.restore();


    }
    draw() {
        if (this.fadeFill < 1) {
            firstFrameBufferGraphics.save();

            firstFrameBufferGraphics.globalAlpha = this.fadeFill;
            const fadeFillScaled = 1 / this.fadeFill * this.width;

            firstFrameBufferGraphics.translate((this.x + this.width / 2) - (this.width / 2 * this.fadeFill), (this.y + this.height / 2) - (this.height / 2 * this.fadeFill));
            firstFrameBufferGraphics.scale(this.fadeFill, this.fadeFill);

            // this.drawDecor(0, 0);
            firstFrameBufferGraphics.drawImage(this.canvas, 0, 0);
            this.topBar(0, 0);

            firstFrameBufferGraphics.restore();
        } else {
            // this.drawDecor(this.x, this.y);
            firstFrameBufferGraphics.drawImage(this.canvas, this.x, this.y);
            this.topBar(this.x, this.y);
        }
    }
    initProcesses() {
        for (let i = 0; i < this.processesBuffer.length; i++) {
            let windowProcess = () => {
                let originalMouseX = devices.mouse.x;
                let originalMouseY = devices.mouse.y;
                devices.mouse.x -= this.x;
                devices.mouse.y -= this.y;

                if(cheapRender === true){
                    this.graphics.save();
                    this.graphics.translate(this.x, this.y);
                    this.canvas.width = this.width;
                    this.canvas.height = this.height;
                    this.processesBuffer[i].command(this.canvas, this.graphics);
                    this.graphics.restore();
                }else{
                    this.processesBuffer[i].command(this.canvas, this.graphics);
                }

                devices.mouse.x = originalMouseX;
                devices.mouse.y = originalMouseY;
            };
            let processBuffer = new Process(windowProcess, this.processesBuffer[i].priority);
            processBuffer.processName = this.processesBuffer[i].processName;
            this.processes.push(processBuffer);
            processes.push(processBuffer);
        }
        //Top bar process
        if(cheapRender === true && this.topBarHeight > 0){
            let processBuffer = new Process(() => {this.topBar(this.x, this.y)}, 1);
            processBuffer.processName = this.windowName + " top bar";
            this.processes.push(processBuffer);
            processes.push(processBuffer);
        }
    }
    init() {
        this.x = this.x - this.width / 2;
        this.y = this.y - this.height / 2;
    }
    updateLogic() {
        this.canvas.width = this.width;
        this.canvas.height = this.height;
        //Focus
        if(devices.mouse.x > this.x && devices.mouse.x < this.x + this.width && devices.mouse.y > this.y - this.topBarHeight && devices.mouse.y < this.y + this.height && this.focusable && devices.mouse.pressed){
            this.requestFocus = true;
        }
        //Window dragging and top bar interaction
        if(this.hasFocus){
            if (devices.mouse.x > this.x + this.width - windowButtonPadding - (this.topBarHeight - windowButtonPadding * 2) &&
            devices.mouse.y > this.y + windowButtonPadding - (this.topBarHeight - 1) &&
            devices.mouse.x < this.x + this.width - windowButtonPadding &&
            devices.mouse.y < this.y + (windowButtonPadding - (this.topBarHeight - 1)) + (this.topBarHeight - windowButtonPadding * 2) && devices.mouse.pressed && this.dragged === false) {
            this.close();
            return;
            }
            if (devices.mouse.x > this.x && devices.mouse.x < this.x + this.width && devices.mouse.y > this.y - this.topBarHeight && devices.mouse.y < this.y && devices.mouse.pressed && this.dragged === false && this.hasFocus) {
                this.initialDrag = {
                    mouseX: devices.mouse.x,
                    mouseY: devices.mouse.y,
                    windowX: this.x,
                    windowY: this.y
                }
                this.dragged = true;
            }
            if (this.dragged === true) {
                if (!devices.mouse.pressed) {
                    this.dragged = false;
                }
                this.x = (devices.mouse.x - this.initialDrag.mouseX) + this.initialDrag.windowX;
                this.y = (devices.mouse.y - this.initialDrag.mouseY) + this.initialDrag.windowY;
            }
        }
        //Animations
        if(cheapGraphics !== true){
            if(this.dying !== true){
                if (Math.round(this.fadeFill*100)/100 < 1) {
                    this.fadeFill += (getTransition(1, 500) - (getTransition(this.fadeFill, 500))) * 2;
                } else {
                    this.fadeFill = 1;
                }    
            }else {
                if(this.fadeFill > 0){
                    this.fadeFill -= (getTransition(1, 500) - (getTransition(1-this.fadeFill, 500))) * 2;
                }else{
                    this.fadeFill = 0;
                    this.dead = true;
                }
            }
        }else{
            this.fadeFill = 1;
        }
        if(this.dying === true && this.dead === true){
            //Kill all processes linked to the window
            for (let i = 0; i < this.processes.length; i++) {
                for (let l = 0; l < processes.length; l++) {
                    if (processes[l].PID === this.processes[i].PID) {
                        processes.splice(l, 1);
                    }
                }
            }
        }
    }
}

function createWindow(windowProcesses, name) {
    let currentWindow = new GraphiteWindow(windowProcesses, name);
    currentWindow.init();
    currentWindow.initProcesses();
    windows.push(currentWindow);
}
function quickWindow(command, name) {
    let currentWindow = new GraphiteWindow([new Process(command)], name);
    currentWindow.init();
    currentWindow.initProcesses();
    windows.push(currentWindow);
}

//Mouse cursor
let cursorHandler = function () { };
var cursorFunction = function () { };
function setCursor(cursorDrawHandler) {
    cursorHandler = cursorDrawHandler;
    let cursorOffscreenCanvas = document.createElement("canvas");
    cursorOffscreenCanvas.width = 32;
    cursorOffscreenCanvas.height = 32;
    let cursorOffscreenGraphics = cursorOffscreenCanvas.getContext("2d");
    if(cheapGraphics === false){
        cursorOffscreenGraphics.filter = "drop-shadow(6px 4px 1px rgba(0,0,0,0.5))";
    }
    cursorDrawHandler(cursorOffscreenGraphics);
    cursorFunction = function () {
        firstFrameBufferGraphics.drawImage(cursorOffscreenCanvas, devices.mouse.x, devices.mouse.y);
    }
}
setCursor(graphics => {//Default graphite wm cursor
    graphics.strokeStyle = 'black';
    graphics.fillStyle = 'white';
    graphics.lineWidth = 1;
    graphics.beginPath();
    //Base (left)
    graphics.moveTo(0, 0);
    graphics.lineTo(0, 13);
    //Handle (left)
    graphics.lineTo(3, 10);
    //Handle base (l/r)
    graphics.lineTo(5, 15);
    graphics.lineTo(8, 14);
    //Handle (right)
    graphics.lineTo(6, 9);
    //Base (right)
    graphics.lineTo(10, 9);
    graphics.lineTo(0, 0);

    graphics.fill();
    graphics.stroke();
});

//Manage the window manager
function resetWindow(window){
    let currentWindowBuffer = new GraphiteWindow(window.originalProcesses, window.windowName);
    currentWindowBuffer.x = window.x;
    currentWindowBuffer.y = window.y;
    currentWindowBuffer.width = window.width;
    currentWindowBuffer.height = window.height;
    currentWindowBuffer.focusable = window.focusable;
    currentWindowBuffer.topBarHeight = window.topBarHeight;
    currentWindowBuffer.fadeFill = window.fadeFill;
    currentWindowBuffer.hasFocus = window.hasFocus;

    window.close();

    currentWindowBuffer.initProcesses();
    return currentWindowBuffer;
}
function reloadWindowManager(){
    let windowsBuffer = [];
    for(let i = 0; i < windows.length; i++){
        windowsBuffer[i] = resetWindow(windows[i]);
    }
    setCursor(cursorHandler);
    windows = windowsBuffer;
}

//Hide system cursor to replace with wm cursor
document.body.style.cursor = 'none';
//Generic background
graphics.fillStyle = 'gray';
graphics.fillRect(0, 0, canvas.width, canvas.height);

let windowManagerDrawIndex = 0;
function windowManagerDraw() {
    if(cheapRender === false){
        for (let i = 0; i < windows.length; i++) {
            windows[i].draw();
        }
    }
    cursorFunction();
}
function windowManagerLogic() {
    var requestedWindowIndex = -1;
    for (let i = 0; i < windows.length; i++) {
        windows[i].updateLogic();
        if (windows[i].dead === true) {
            windows.splice(i, 1);
            break;
        }
        if(windows[i].requestFocus === true && requestedWindowIndex === -1){
            requestedWindowIndex = i;
        }
    }
    if(requestedWindowIndex !== -1){
        let focusedWindow = windows[requestedWindowIndex];
        focusedWindow.hasFocus = true;
        windows.splice(requestedWindowIndex, 1);
        windows.push(focusedWindow);
    }
}
if(useBuffering === true){
    function drawFrameBuffer() {
        if(dynamicTripleBuffering){
            if(false){
                graphics.drawImage(firstFrameBuffer, 0, 0);
            }else{
                graphics.drawImage(secondFrameBuffer, 0, 0);
                secondFrameBufferGraphics.drawImage(firstFrameBuffer, 0, 0);
                // console.log("hi");
            }
        }else{
            graphics.drawImage(firstFrameBuffer, 0, 0);
        }
    }
    createProcess(drawFrameBuffer, -2);
}

createProcess(windowManagerLogic, 4);
createProcess(windowManagerDraw, -1);var applications = [];
var applicationReloadTriggered = false;
class Application {
    constructor(handler, icon){
        this.handler = handler;
        this.icon = icon;
    }
}
function triggerApplicationReload() {
    applicationReloadTriggered = true;
}
function addApplication(handler, icon){
    applications.push(new Application(handler, icon));
    triggerApplicationReload();
}
function addApplicationFromClass (appClass) {
  var currentAppClass = new appClass;
  addApplication(currentAppClass.createWindow, currentAppClass.iconFunction);
}
function renderApplicationIcon(application){
    push();
    application.icon();
    pop();
}
function runApplication(application){
    application.handler();
}
//Mouse cursor
function colorBlackCursor(graphics) {
  graphics.strokeStyle = 'white';
  graphics.fillStyle = 'black';
}
function colorWhiteCursor(graphics) {
  graphics.strokeStyle = 'black';
  graphics.fillStyle = 'white';
}
function simpleCursor() {
  //BETA mouse cursor
  graphics.ellipse(0, 0, 10);
}
function macCursor() {
  strokeWeight(1.4);
  beginShape();
  //Base (left)
  vertex(0, 0);
  vertex(0, 19);
  //Handle (left)
  vertex(4, 15);
  //Handle base (l/r)
  vertex(7, 22);
  vertex(11, 20);
  //Handle (right)
  vertex(8, 14);
  //Base (right)
  vertex(13, 14);
  vertex(0, 0);
  endShape();
}
function winCursor() {
  strokeWeight(1);
  beginShape();
  //Base (left)
  vertex(0, 0);
  vertex(0, 16);
  //Handle (left)
  vertex(4, 13);
  //Handle base (l/r)
  vertex(6, 18);
  vertex(9, 17);
  //Handle (right)
  vertex(7, 12);
  //Base (right)
  vertex(12, 12);
  vertex(0, 0);
  endShape();
}
function winCursorOG() {
  strokeWeight(0.8);
  beginShape();
  //Base (left)
  vertex(0, 0);
  vertex(0, 16);
  //Handle (left)
  vertex(3, 12);
  //Handle base (l/r)
  vertex(6, 20);
  vertex(9, 19);
  //Handle (right)
  vertex(6, 11);
  //Base (right)
  vertex(11, 11);
  vertex(0, 0);
  endShape();
}
let kCursor = graphics => {
  graphics.lineJoin = 'round';
  graphics.lineWidth = 1;
  graphics.beginPath();
  //Base (left)
  graphics.moveTo(0, 0);
  graphics.lineTo(0, 13);
  //Handle (left)
  graphics.lineTo(3, 10);
  //Handle base (l/r)
  graphics.lineTo(5, 15);
  graphics.lineTo(8, 14);
  //Handle (right)
  graphics.lineTo(6, 9);
  //Base (right)
  graphics.lineTo(10, 9);
  graphics.lineTo(0, 0);

  graphics.fill();
  graphics.stroke();
}
let cursorColor = 
  colorBlackCursor
  // colorWhiteCursor
  ;
let cursorShape =
  //Ranked from worst to best :P
  // simpleCursor
  // winCursor
  // winCursorOG
  // macCursor
  kCursor
  ;
let renderMouseCursor = graphics => {
  cursorColor(graphics);
  cursorShape(graphics);
}
//Use kwm as the mouse cursor rendering engine
setCursor(renderMouseCursor);

//Applications
//Icon creation function
function createIcon(iconFunction, x, y, size, createWindowFunction) {
  let iconProcess = new Process((canvas, graphics) => {
    iconFunction(canvas, graphics);
    if(devices.mouse.x > 0 && devices.mouse.x < canvas.width && devices.mouse.y > 0 && devices.mouse.y < canvas.height && buttonClicked === false && devices.mouse.clicked){
      createWindowFunction();
      buttonClicked = true;
    }
  });
  iconProcess.processName = "icon";
  var icon = new GraphiteWindow([iconProcess], "icon");
  icon.x = x;
  icon.y = y;
  icon.width = size;
  icon.height = size;
  icon.topBarHeight = 0;
  icon.focusable = false;
  icon.initProcesses();

  windows.push(icon);
}

//Rayhamburger
function rainbow() { }
rainbow.prototype.iconFunction = function (canvas, graphics) {
  graphics.fillStyle = "#FF6464";
  graphics.fillRect(0,0,canvas.width,canvas.height/3);
  graphics.fillStyle = "#64FF64";
  graphics.rect(0,canvas.height/3,canvas.width,canvas.height/3);
  graphics.fillStyle = "#6464FF";
  graphics.rect(0,canvas.height*(2/3),canvas.width,canvas.height/3);
}
rainbow.prototype.createWindow = function () {
  quickWindow(RenderRainbow, "Rainbow (not gay)");
}

//Add applications
addApplicationFromClass(TTY);//JSTerm
addApplicationFromClass(Settings);//Settings
addApplicationFromClass(SOTF);//Survival of the Fittest
addApplicationFromClass(CookieClicker);//Cookie Clicker
addApplicationFromClass(Autoclick);//Cookie Clicker
//addApplicationFromClass(Rayham);//Raycast
addApplicationFromClass(rainbow);//Render Rainbow
//App Dock
class appDock{
  constructor () {
    this.iconSize = 96;
    this.iconPadding = this.iconSize / 8;
    this.pressed = false;
  }
  createIcons () {
    for (let i = 0; i < applications.length; i++) {
      let iconX = canvas.width / 2 + (this.iconSize + this.iconPadding) * i - applications.length * this.iconSize / 2;
      let iconY = canvas.height - this.iconSize - this.iconPadding*2;
      var self = this;
      setTimeout(() => { createIcon(applications[i].icon, iconX, iconY,
        self.iconSize,applications[i].handler) }, 500 + (100 * i));
    }
  }
}
var appDockSystem = new appDock();
//Background
RenderRainbow = (canvas, graphics) => {
  let gradient = graphics.createLinearGradient(0, 0, canvas.width, canvas.height);
  gradient.addColorStop("0", "red");
  gradient.addColorStop("0.17", "orange");
  gradient.addColorStop("0.33", "yellow");
  gradient.addColorStop("0.5", "green");
  gradient.addColorStop("0.67" ,"blue");
  gradient.addColorStop("0.83" ,"indigo");
  gradient.addColorStop("1.0", "violet");

  graphics.fillStyle = gradient;
  graphics.fillRect(0, 0, canvas.width, canvas.height);
  graphics.font = "48px Arial";
  graphics.fillStyle = "black";
  graphics.fillText("(Not gay)", canvas.width/2 - graphics.measureText("(Not gay)").width/2, 80);
}
function BandaiNamco (canvas, graphics) {
  this.resolutionScale = 50;
  graphics.strokeStyle = 'white';
  for (var i = 0; i < canvas.height; i += this.resolutionScale) {
    var heightScale = i * (510 / canvas.height);
    graphics.fillStyle = `rgb(
      ${heightScale / 2},
      ${100 - (heightScale / 2)},
      ${255 - (heightScale / 2)}`;
    graphics.fillRect(0, i, canvas.width, this.resolutionScale * 2);
  }
}
creasedJacket = (canvas, graphics) => {
  if(!this.init){
    this.init = true;
    this.gradient = graphics.createLinearGradient(0, 0, 0, canvas.height);
    this.gradient.addColorStop("0", "red");
    this.gradient.addColorStop("0.5" ,"purple");
    this.gradient.addColorStop("1.0", "aqua");
  }
  graphics.fillStyle = this.gradient;
  graphics.fillRect(0, 0, canvas.width, canvas.height);
}

GenericBackground = (canvas, graphics) => {
  graphics.fillStyle = "white";
  graphics.fillRect(0, 0, canvas.width, canvas.height);
  // console.log(graphics.fillStyle)
}
// backgroundFunction = RenderRainbow;
// backgroundFunction = GenericBackground;
// backgroundFunction = imageBackground;
// backgroundFunction = BandaiNamco;
backgroundFunction = creasedJacket;
createBackgroundWindow = () => {
  let background = new GraphiteWindow([new Process(backgroundFunction)], "background", false);
  background.x = 0;
  background.y = 0;
  background.width = canvas.width;
  background.height = canvas.height;
  background.topBarHeight = 0;
  background.focusable = false;
  background.initProcesses();
  windows.push(background);
}

function kshellErrorScreenDaemon (process, error) {
    let self = this;
    graphics.save();
    if (this.init === undefined) {
        for (var i = 0; i < processes.length; i++) {
            processes[i].manualSuspend = true;
        }
        this.init = true;
    }
    function returnSystem() {
        for (var i = 0; i < processes.length; i++) {
            processes[i].manualSuspend = false;
        }
        systemError = [];
        self.init = undefined;
    }
    graphics.fillStyle = "#FF3333";
    graphics.fillRect(0, 0, canvas.width, canvas.height);
    graphics.font = "16px Monospace";
    graphics.fillStyle = 'black';
    graphics.fillText("Your system has encountered an error.", 10, canvas.height / 4);
    graphics.fillText("To ignore the error and continue to use the system, press [SPACE BAR].", 10, canvas.height / 3);
    graphics.fillText("To kill the process and return to your system, press [Q].", 10, canvas.height / 2.7);
    graphics.fillText(error, 10, canvas.height / 1.5);
    graphics.fillText("Process ID: " + process.PID, 10, canvas.height / 1.2);
    graphics.fillText("Check console for more details.", 10, canvas.height / 1.4);
    if (devices.keyboard.keyCodes[81]) {
        kill(process.PID);
        returnSystem();
    } else if (devices.keyboard.keyCodes[32]) {
      try{
        process.command();
      } catch (processError){
        alert("Process in consistent error. Killing process.");
        kill(process.PID);
      }
      returnSystem();
    }
}
errorScreenFunction = kshellErrorScreenDaemon;

//Create background window
createBackgroundWindow();
//Create dock icons
appDockSystem.createIcons();

//Create functions for each set of processes
function updateAppDockSystem() {
  appDockSystem.update();
}
//Create process group for kshell
var kshellProcessGroup = [];

//Create processes
//Appdock
        </script>
    </body>
</html>